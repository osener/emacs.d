#+TITLE: Ozan Sener's Emacs configuration
#+OPTIONS: toc:nil num:nil ^:nil
* Load some lisp
#+begin_src emacs-lisp
  (require 'cl)

  (defun load-secrets ()
    (interactive)
    (require 'secrets "~/.emacs.d/secrets.el.gpg"))
#+end_src

Install some additional packages
#+begin_src emacs-lisp
  (require-package 'starter-kit-bindings)
  (require-package 'yasnippet)
  (require-package 'jade-mode)
  (require-package 'stylus-mode)
  (require-package 'dash)
  (require-package 'multiple-cursors)
  (require-package 'async)
  (require-package 'restclient)
  (require-package 'typo)
  (require-package 'dic-lookup-w3m)
#+end_src

* Programming languages
** Scheme
#+begin_src emacs-lisp
  (add-hook 'scheme-mode-hook 'sanityinc/lisp-setup)
#+end_src
*** Chicken Scheme
Load chicken
#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/local/lib/chicken/6/")
  (autoload 'chicken-slime "chicken-slime" "SWANK backend for Chicken" t)
  (add-hook 'scheme-mode-hook
            (lambda ()
              (slime-mode t)))
#+end_src
** Clojure
#+begin_src emacs-lisp
  (require-package 'lein)
#+end_src

Static checking using kibit
#+begin_src emacs-lisp
  (require 'compile)
  (add-to-list 'compilation-error-regexp-alist-alist
               '(kibit "At \\([^:]+\\):\\([[:digit:]]+\\):" 1 2 nil 0))
  (add-to-list 'compilation-error-regexp-alist 'kibit)

  ;; A convenient command to run "lein kibit" in the project to which
  ;; the current emacs buffer belongs to.
  (defun kibit ()
    "Run kibit on the current project.
  Display the results in a hyperlinked *compilation* buffer."
    (interactive)
    (compile "lein kibit"))
#+end_src
** Python
#+begin_src emacs-lisp
  (require-package 'virtualenv)
  (require-package 'python-pep8)
  (require-package 'python-pylint)
#+end_src

Code completion using IPython
#+begin_src emacs-lisp
  (setq python-shell-interpreter "ipython"
        python-shell-interpreter-args ""
        python-shell-prompt-regexp "In \\[[0-9]+\\]: "
        python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
        python-shell-completion-setup-code
        "from IPython.core.completerlib import module_completion"
        python-shell-completion-module-string-code
        "';'.join(module_completion('''%s'''))\n"
        python-shell-completion-string-code
        "';'.join(get_ipython().Completer.all_completions('''%s'''))\n")
#+end_src

Auto-indentation
#+begin_src emacs-lisp
  (add-hook 'python-mode-hook
    #'(lambda ()
        (define-key python-mode-map "\C-m" 'newline-and-indent)))
#+end_src

** C
Auto indentation (C-j is harder to reach on Colemak)
#+begin_src emacs-lisp
  (add-hook 'c-mode-common-hook '(lambda ()
        (local-set-key (kbd "RET") 'newline-and-indent)))
#+end_src
** Javascript
#+begin_src emacs-lisp
  (setq js2-concat-multiline-strings 'eol
        js2-rebind-eol-bol-keys t
        js2-idle-timer-delay 0.1
        js2-strict-inconsistent-return-warning nil)

  (require 'js2-imenu-extras)
  (js2-imenu-extras-setup)
#+end_src

*** Declare globals
#+begin_src emacs-lisp
  (setq-default js2-global-externs '("module" "require" "jQuery"
                                     "$" "_" "buster" "assert"
                                     "setTimeout" "clearTimeout"
                                     "setInterval" "clearInterval"
                                     "__dirname" "console" "JSON"
                                     "cengiz"))


  ;; After js2 has parsed a js file, we look for jslint globals decl comment
  ;; ("/* global Fred, _, Harry */") and add any symbols to a buffer-local var of
  ;; acceptable global vars Note that we also support the "symbol: true" way of
  ;; specifying names via a hack (remove any ":true" to make it look like a plain
  ;; decl, and any ':false' are left behind so they'll effectively be ignored as
  ;; you can't have a symbol called "someName:false"
  (add-hook 'js2-post-parse-callbacks
            (lambda ()
              (when (> (buffer-size) 0)
                (let ((btext (replace-regexp-in-string
                              ": *true" " "
                              (replace-regexp-in-string "[\n\t ]+" " " (buffer-substring-no-properties 1 (buffer-size)) t t))))
                  (mapc (apply-partially 'add-to-list 'js2-additional-externs)
                        (split-string
                         (if (string-match "/\\* *global *\\(.*?\\) *\\*/" btext) (match-string-no-properties 1 btext) "")
                         " *, *" t))
                  ))))
#+end_src
*** Insert semicolons automatically
#+begin_src emacs-lisp
  (require 'js2-mode)
  (defvar js2-semicolon-contexts
    (list js2-NAME js2-LP js2-SCRIPT js2-CALL js2-BLOCK))
  (defun autopair-js2-maybe-insert-semi-colon (action pair pos-before)
    "handler for automatically inserting semi-colon at the end of function call."
    (cond ((and (eq action 'opening)
                (eq pair ?\))
                (save-excursion
                  (goto-char pos-before)
                  (skip-chars-backward " \t")
                  (memq (js2-node-type (js2-node-at-point (point)))
                        js2-semicolon-contexts)))
           (save-excursion
             (let ((forward-sexp-function nil))
               (goto-char pos-before)
               (forward-sexp))
             (if (looking-at-p "[^[:graph:]]*$")
                 (insert ";"))))))

  (add-hook 'js2-mode-hook
            '(lambda ()
               (setq autopair-handle-action-fns
                     (list #'autopair-default-handle-action
                           #'autopair-js2-maybe-insert-semi-colon))))
#+end_src

*** Set up Slime with swank-js
#+begin_src emacs-lisp
  (require 'js2-mode)
  (require-package 'slime-js)

  (defun js2-eval-friendly-node-p (n)
    (or (and (js2-stmt-node-p n) (not (js2-block-node-p n)))
        (and (js2-function-node-p n) (js2-function-node-name n))))

  (defun slime-js--echo-result (result &rest _)
    (message result))

  (defun slime-js--replace-with-result (replacement beg end)
    (save-excursion
      (goto-char beg)
      (delete-char (- end beg))
      (insert replacement)))

  (defun slime-js-eval-region (beg end &optional func)
    (lexical-let ((func (or func 'slime-js--echo-result))
                  (beg beg)
                  (end end))
      (slime-flash-region beg end)
      (slime-js-eval
       (buffer-substring-no-properties beg end)
       #'(lambda (s) (funcall func (cadr s) beg end)))))

  (defun slime-js-eval-statement (&optional func)
    (let ((node (js2r--closest 'js2-eval-friendly-node-p)))
      (slime-js-eval-region (js2-node-abs-pos node)
                            (js2-node-abs-end node)
                            func)))

  (defun slime-js-eval-current ()
    (interactive)
    (if (use-region-p)
        (slime-js-eval-region (point) (mark))
      (slime-js-eval-statement)))

  (defun slime-js-eval-and-replace-current ()
    (interactive)
    (if (use-region-p)
        (slime-js-eval-region (point) (mark) 'slime-js--replace-with-result)
      (slime-js-eval-statement 'slime-js--replace-with-result)))

  (defun set-up-slime-js ()
    (require 'slime)
    (slime-js-minor-mode 1)

    (global-set-key [f5] 'slime-js-reload)

    (define-key slime-js-minor-mode-map (kbd "C-x C-e") (lambda ()
                                                          (interactive)
                                                          (ignore-errors (slime-js-eval-current))))
      (define-key slime-js-minor-mode-map (kbd "C-c C-e") '(lambda ()
                                                          (interactive)
                                                          (ignore-errors
                                                            (slime-js-eval-and-replace-current))))

    (defadvice slime-js-event-hook-function (after slime-js-yasnippet activate)
      (setq yas/mode-symbol 'js2-mode)))

  (add-hook 'js2-mode-hook 'set-up-slime-js)
#+end_src

*** Slime auto-completion
#+begin_src emacs-lisp
  (defun rk/ac-slime-js-valid-start (string)
    (string-match-p "[0-9a-zA-Z_$\\.]" string))

  (defun rk/ac-slime-js-prev-partial-sexp ()
    "get the expression before (point)"
    (let* ((start (string (preceding-char)))
           (paren-or-quote (string-match-p "[\\)\"\']" start)))
      (cond
       ((rk/ac-slime-js-valid-start start)
        (goto-char (1- (point)))
        (point))
       (paren-or-quote (rk/smart-nav-backward) (point)))))

  (defun rk/ac-slime-js-prefix ()
    (interactive)
    (or (when (rk/ac-slime-js-valid-start (string (preceding-char)))
          (save-excursion
            (while (rk/ac-slime-js-prev-partial-sexp))
            (point))) (point)))

  (defun rk/ac-slime-js-prefix-string ()
    "Mainly used for debugging"
    (interactive)
    (buffer-substring-no-properties (rk/ac-slime-js-prefix) (point)))

  (defun rk/transform-simple-completion ()
    ;; (slime-simple-completions ac-prefix)
    (let ((result (slime-simple-completions ac-prefix)))
      (destructuring-bind (completions partial) result
        ;; completions
        (let ((transformed (mapcar
                            (lambda (s) (substring s (length ac-prefix)))
                            completions)))
          transformed))))

  (defun rk/setup-slime-js-ac-source ()
    (ac-define-source slime-js
      '((candidates . rk/transform-simple-completion)
        (prefix     . rk/ac-slime-js-prefix)
        (match      . (lambda (prefix candidates)
                        (mapcar (lambda (candidate)
                                  (concat prefix candidate))
                                candidates)))
        (requires   . 0))))

  (rk/setup-slime-js-ac-source)

  (add-hook 'js2-mode-hook
            (lambda () (add-to-list 'ac-sources 'ac-source-slime-js)))
#+end_src
*** Syntax checking with jshint
#+begin_src emacs-lisp
  (require 'flymake)
  (setq flymake-run-in-place nil)

  (dolist (hook '(js2-mode-hook js3-mode-hook js-mode-hook))
    (add-hook hook (lambda () (flymake-mode t))))
#+end_src
*** json-mode
#+begin_src emacs-lisp
  (require 'json-mode)
  (add-to-list 'auto-mode-alist '("\\.json$" . json-mode))
#+end_src
*** Use lambda for anonymous functions
#+begin_src emacs-lisp
  (font-lock-add-keywords
   'js2-mode `(("\\(function\\) *("
                (0 (progn (compose-region (match-beginning 1)
                                          (match-end 1) "\u0192")
                          nil)))))
#+end_src
*** Use right arrow for return in one-line functions
#+begin_src emacs-lisp
  (font-lock-add-keywords
   'js2-mode `(("function *([^)]*) *{ *\\(return\\) "
                (0 (progn (compose-region (match-beginning 1)
                                          (match-end 1) "\u2190")
                          nil)))))
#+end_src
*** Refactoring
#+begin_src emacs-lisp
  (require-package 'js2-refactor)

  (require 'js2-refactor)

  (defadvice js2r-inline-var (after reindent-buffer activate)
    (cleanup-buffer))
#+end_src
*** Auto-completion using Skewer
#+begin_src emacs-lisp
  (require-package 'ac-js2)
  (setq ac-js2-evaluate-calls t)
  (setq ac-js2-external-libraries '("~/jslibs/underscore.js"))
#+end_src

** Scala
#+begin_src emacs-lisp
  (require-package 'scala-mode2)

  (let ((default-directory "~/vcs/ensime"))
    (when (file-exists-p default-directory)
      (add-to-list 'load-path (expand-file-name "elisp/"))
      (require 'ensime)))
#+end_src
* Eshell
Great intro post for eshell, also the source of some of these settings:
http://www.masteringemacs.org/articles/2010/12/13/complete-guide-mastering-eshell/

** Change some defaults
#+begin_src emacs-lisp
  (eval-after-load 'esh-opt
    '(progn
       (require 'em-prompt)
       (setq eshell-cmpl-ignore-case t)
       (setq eshell-prefer-lisp-functions t)
       (setq eshell-where-to-jump 'begin)
       (setq eshell-review-quick-commands nil)
       (setq eshell-smart-space-goes-to-end t)
       (setq eshell-directory-name
             (expand-file-name "./" (expand-file-name "eshell" "~/.emacs.d")))))
#+end_src

** Convenience function for usage in a terminal emulator
This allows you to use eshell in a similar fashion to standard Unix
shells in a terminal emulator.

Call Emacs like this for an one-off eshell buffer:
emacsclient -a '' -t -e "(server-eshell)"
#+begin_src emacs-lisp
  (defun server-eshell ()
    "Command to be called by emacs-client to start a new shell.

  A new eshell will be created. When the frame is closed, the buffer is
  deleted or the shell exits, then hooks will take care that the other
  actions happen. For example, when the frame is closed, then the buffer
  will be deleted and the client disconnected.

  Also creates a local binding of 'C-x #' to kill the buffer."
    (lexical-let ((buf (eshell t))
                  (client (first server-clients))
                  (frame (selected-frame)))
      (labels ((close (&optional arg)
                      (when (not (boundp 'cve/recurse))
                        (let ((cve/recurse t))
                          (delete-frame frame)
                          (kill-buffer buf)
                          (server-delete-client client)))))
        (add-hook 'eshell-exit-hook #'close t t)
        (add-hook 'delete-frame-functions #'close t t))
      (local-set-key (kbd "C-x #") (lambda () (interactive) (kill-buffer buf)))
      (delete-other-windows)
      nil))
#+end_src

** Quake-like eshell window
#+begin_src emacs-lisp
  (require-package 'shell-pop)
  (require 'shell-pop)
  (shell-pop-set-window-position "bottom")
  (shell-pop-set-window-height 50)

  (global-set-key (kbd "M-<f8>")
                  (lambda ()
                    (interactive)
                    (shell-pop-set-internal-mode "terminal")
                    (shell-pop-set-internal-mode-shell "/usr/local/bin/fish")
                    (shell-pop)))

  (global-set-key (kbd "<f8>")
                  (lambda ()
                    (interactive)
                    (shell-pop-set-internal-mode "eshell")
                    (shell-pop)))
#+end_src

** Easy way to open eshell in the directory of current buffer
[[https://github.com/technomancy/emacs-starter-kit/commit/c0e568d3c9940c9dd5241e4b49467723590fc2c2][From here]]
#+begin_src
(defun eshell-in-dir (&optional prompt)
  "Change the directory of an existing eshell to the directory of the file in
the current buffer or launch a new eshell if one isn't running. If the
current buffer does not have a file (e.g., a *scratch* buffer) launch or raise
eshell, as appropriate. Given a prefix arg, prompt for the destination
directory."
  (interactive "P")
  (let* ((original-buffer (current-buffer))
         (name (buffer-file-name))
         (dir (cond (prompt (read-directory-name "Directory: " nil nil t))
                    (name (file-name-directory name))
                    (t nil)))
         (buffers (delq nil (mapcar (lambda (buf)
                                      (with-current-buffer buf
                                        (when (eq 'eshell-mode major-mode)
                                          (buffer-name))))
                                    (buffer-list))))
         (buffer (cond ((eq 1 (length buffers)) (first buffers))
                       ((< 1 (length buffers)) (ido-completing-read
                                                "Eshell buffer: " buffers nil t
                                                nil nil (first buffers)))
                       (t (eshell)))))
    (with-current-buffer buffer
      (when dir
        (eshell/cd (list dir))
        (eshell-send-input))
      (end-of-buffer)
      (switch-to-buffer original-buffer)
      (shell-pop-up))))
#+end_src

** Clickable ls output
[[http://www.emacswiki.org/emacs/EshellEnhancedLS][From EmacsWiki]]
#+begin_src emacs-lisp
  (eval-after-load "em-ls"
    '(progn
       (defun ted-eshell-ls-find-file-at-point (point)
         "RET on Eshell's `ls' output to open files."
         (interactive "d")
         (find-file
          (replace-regexp-in-string
           "[ \t\n]*$" ""
           (replace-regexp-in-string
            "^[ \t\n]*" ""
            (buffer-substring-no-properties
             (previous-single-property-change point 'help-echo)
             (next-single-property-change point 'help-echo))))))

       (defun pat-eshell-ls-find-file-at-mouse-click (event)
         "Middle click on Eshell's `ls' output to open files.
   From Patrick Anderson via the wiki."
         (interactive "e")
         (ted-eshell-ls-find-file-at-point (posn-point (event-end event))))

       (let ((map (make-sparse-keymap)))
         (define-key map (kbd "RET")      'ted-eshell-ls-find-file-at-point)
         (define-key map (kbd "<return>") 'ted-eshell-ls-find-file-at-point)
         (define-key map (kbd "<mouse-2>") 'pat-eshell-ls-find-file-at-mouse-click)
         (defvar ted-eshell-ls-keymap map))

       (defadvice eshell-ls-decorated-name (after ted-electrify-ls activate)
         "Eshell's `ls' now lets you click or RET on file names to open them."
         (add-text-properties 0 (length ad-return-value)
                              (list 'help-echo "RET, mouse-2: visit this file"
                                    'mouse-face 'highlight
                                    'keymap ted-eshell-ls-keymap)
                              ad-return-value)
         ad-return-value)))
#+end_src

** Colorize prompt on nonzero exit codes
#+begin_src emacs-lisp
  (defface esk-eshell-error-prompt-face
    '((((class color) (background dark)) (:foreground "red" :bold t))
      (((class color) (background light)) (:foreground "red" :bold t)))
    "Face for nonzero prompt results"
    :group 'eshell-prompt)

  (add-hook 'eshell-after-prompt-hook
            (defun esk-eshell-exit-code-prompt-face ()
              (when (and eshell-last-command-status
                         (not (zerop eshell-last-command-status)))
                (let ((inhibit-read-only t))
                  (add-text-properties
                   (save-excursion (beginning-of-line) (point)) (point-max)
                   '(face esk-eshell-error-prompt-face))))))
#+end_src

** Misc commands
#+begin_src emacs-lisp
  (defun eshell/cds ()
    "Change directory to the project's root."
    (eshell/cd (locate-dominating-file default-directory "src")))

  (defun eshell/cdl ()
    "Change directory to the project's root."
    (eshell/cd (locate-dominating-file default-directory "lib")))

  (defun eshell/cdg ()
    "Change directory to the project's root."
    (eshell/cd (locate-dominating-file default-directory ".git")))
#+end_src

* Term
Don't keep buffers with finished processes around
#+begin_src emacs-lisp
  (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
    (if (memq (process-status proc) '(signal exit))
        (let ((buffer (process-buffer proc)))
          ad-do-it
          (kill-buffer buffer))
      ad-do-it))
  (ad-activate 'term-sentinel)
#+end_src

Yank into terminal with C-y
#+begin_src emacs-lisp
  (defun my-term-paste (&optional string)
   (interactive)
   (process-send-string
    (get-buffer-process (current-buffer))
    (if string string (current-kill 0))))

  (add-hook 'term-mode-hook
            (lambda () (define-key term-raw-map "\C-y" 'my-term-paste)))
#+end_src

* Dired
Toggleable verbosity
#+begin_src emacs-lisp
  (require-package 'dired-details)
  (require-package 'dired-details+)

  (require 'dired-details+)
  (setq-default dired-details-hidden-string "--- ")
#+end_src

Custom ls invocation
#+begin_src emacs-lisp
  (setq dired-listing-switches
        "-aGhlvF --group-directories-first --time-style=long-iso")
#+end_src

Try guessing dired targets
#+begin_src emacs-lisp
  (setq dired-dwim-target t)
#+end_src

Don't ask before doing recursive copies
#+begin_src emacs-lisp
  (setq dired-recursive-copies 'always)
#+end_src
* Navigation
Goto line with feedback
#+begin_src emacs-lisp
  (global-set-key [remap goto-line] 'goto-line-with-feedback)

  (defun goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input"
    (interactive)
    (if (and (boundp 'linum-mode)
             linum-mode)
        (call-interactively 'goto-line)
      (unwind-protect
          (progn
            (linum-mode 1)
            (call-interactively 'goto-line))
        (linum-mode -1))))
#+end_src
* Window management
Popwin
#+begin_src emacs-lisp
  (require-package 'popwin)

  (require 'popwin)
  (setq display-buffer-function 'popwin:display-buffer)

  (setq popwin:special-display-config
        '(("*Help*" :height 30 :stick t)
          ("*Completions*" :noselect t)
          ("*compilation*" :noselect t)
          ("*Messages*" :height 30)
          ("*Occur*" :noselect t)
          ("*Directory*" :noselect t)
          ("*Packages*" :height 30)
          ("*ack-and-a-half*" :noselect t)
          ("\\*Slime Description.*" :noselect t :regexp t :height 30)
          ("*magit-commit*" :noselect t :height 40 :width 80)
          ("*magit-diff*" :noselect t :height 40 :width 80)
          ("*magit-edit-log*" :noselect t :height 15 :width 80)
          ("\\*Slime Inspector.*" :regexp t :height 30)
          ("*Ido Completions*" :noselect t :height 30)
          ("\\*ansi-term\\*.*" :regexp t :height 30)
          ("*shell*" :height 30)
          ("*gists*" :height 30)
          ("*sldb.*":regexp t :height 30)))
#+end_src
Rotate windows
#+begin_src emacs-lisp
  (defun rotate-windows ()
    "Rotate your windows"
    (interactive)
    (cond ((not (> (count-windows)1))
           (message "You can't rotate a single window!"))
          (t
           (setq i 1)
           (setq numWindows (count-windows))
           (while  (< i numWindows)
             (let* (
                    (w1 (elt (window-list) i))
                    (w2 (elt (window-list) (+ (% i numWindows) 1)))

                    (b1 (window-buffer w1))
                    (b2 (window-buffer w2))

                    (s1 (window-start w1))
                    (s2 (window-start w2))
                    )
               (set-window-buffer w1  b2)
               (set-window-buffer w2 b1)
               (set-window-start w1 s2)
               (set-window-start w2 s1)
               (setq i (1+ i)))))))
#+end_src

Toggle window split
#+begin_src emacs-lisp
  (defun toggle-window-split ()
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))
#+end_src

Keybindings
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x -") 'rotate-windows)
  (global-set-key (kbd "C-x C--") 'toggle-window-split)
  (global-unset-key (kbd "C-x C-+")) ;; don't zoom like this
#+end_src
* Email
Mu4e (http://www.djcbsoftware.nl/code/mu/) is e great mail reader.
#+begin_src sh
  brew install offlineimap
  brew install mu --with-emacs
#+end_src

#+begin_src emacs-lisp
  (require 'mu4e)

  (setq mu4e-drafts-folder "/[Gmail].Drafts")
  (setq mu4e-sent-folder   "/[Gmail].Sent Mail")
  (setq mu4e-trash-folder  "/[Gmail].Trash")

  ;; setup some handy shortcuts
  (setq mu4e-maildir-shortcuts
        '( ("/INBOX"               . ?i)
           ("/[Gmail].Sent Mail"   . ?s)
           ("/[Gmail].Trash"       . ?t)
           ("/[Gmail].All Mail"    . ?a)))

  ;; allow for updating mail using 'U' in the main view:
  (setq mu4e-get-mail-command "offlineimap")

  ;; something about ourselves
  (setq
   user-mail-address "ozan@ozansener.com"
   user-full-name  "Ozan Sener"
   message-signature
   (concat
    "Ozan Sener\n"
    "http://ozansener.com\n"))

  (setq mail-user-agent 'mu4e-user-agent)

  (setq message-send-mail-function 'smtpmail-send-it
        smtpmail-stream-type 'starttls
        starttls-use-gnutls t
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587)

  (setq mu4e-bookmarks
        '( ("flag:unread AND NOT flag:trashed" "Unread messages"      ?u)
           ("date:today..now"                  "Today's messages"     ?t)
           ("date:7d..now"                     "Last 7 days"          ?w)
           ("mime:image/*"                     "Messages with images" ?i)))

  (setq mu4e-update-interval 900
        mu4e-html2text-command "w3m -dump -T text/html"
        mu4e-confirm-quit nil
        mu4e-headers-date-format "%B %e, %Y"
        mu4e-refile-folder "/Archives"
        mu4e-show-images t
        mu4e-use-fancy-chars t)

#+end_src

* Chat
#+begin_src emacs-lisp
  (defun start-im ()
    (interactive)
    (load-secrets)
    (sauron-start-hidden)
    (znc-all))
#+end_src

** ERC
Unique nick colorization
#+begin_src emacs-lisp
  (require-package 'erc-hl-nicks)
#+end_src

Disable trailing whitespace in ERC buffers
#+begin_src emacs-lisp
  (add-hook 'erc-mode-hook (lambda ()
                                (setq show-trailing-whitespace nil)))
#+end_src

Growl notifications
#+begin_src emacs-lisp
  (defun my-erc-hook (match-type nick message)
    "Shows a growl notification, when user's nick was mentioned. If the buffer is currently not visible, makes it sticky."
    (unless (posix-string-match "^\\** *Users on #" message)
      (todochiku-message
       "ERC"
       (concat "Name mentioned on: " (buffer-name (current-buffer)))
       (todochiku-icon 'irc))))
  (add-hook 'erc-text-matched-hook 'my-erc-hook)
#+end_src

ZNC
#+begin_src emacs-lisp
  (require 'znc)
#+end_src
* Helm
#+begin_src emacs-lisp
  (require-package 'helm)
  (require-package 'helm-ls-git)

  (require 'helm-config)
  (setq helm-ls-git-show-abs-or-relative 'relative)
#+end_src

Eshell completion
#+begin_src emacs-lisp
  (require 'helm-files)

  (add-hook 'eshell-mode-hook
            #'(lambda ()
                (define-key eshell-mode-map
                  (kbd "M-p")
                  'helm-eshell-history)))
#+end_src

Ipython completion
#+begin_src emacs-lisp
  (require 'helm-ipython)
  (define-key python-mode-map (kbd "M-<tab>")
    'helm-ipython-complete)
#+end_src

Elisp completion
#+begin_src emacs-lisp
  (define-key emacs-lisp-mode-map (kbd "M-<tab>")
    'helm-lisp-completion-at-point)
#+end_src

JavaScript completion
#+begin_src emacs-lisp
  (define-key js2-mode-map (kbd "M-<tab>")
    'helm-slime-complete)
#+end_src

Keybindings
#+begin_src emacs-lisp
  (global-set-key (kbd "<f1>") 'helm-mini)
  (global-set-key (kbd "s-t") 'helm-ls-git-ls)
#+end_src

* Git
Toggle whitespace in magit-status buffers
#+begin_src emacs-lisp
  (require 'magit)

  (defun magit-toggle-whitespace ()
    (interactive)
    (if (member "-w" magit-diff-options)
        (magit-dont-ignore-whitespace)
      (magit-ignore-whitespace)))

  (defun magit-ignore-whitespace ()
    (interactive)
    (add-to-list 'magit-diff-options "-w")
    (magit-refresh))

  (defun magit-dont-ignore-whitespace ()
    (interactive)
    (setq magit-diff-options (remove "-w" magit-diff-options))
    (magit-refresh))

  (define-key magit-status-mode-map (kbd "W") 'magit-toggle-whitespace)
#+end_src

Diff-hl mode
#+begin_src emacs-lisp
  (require-package 'diff-hl)
  (global-diff-hl-mode t)
#+end_src

Style-checking for git commit messages
#+begin_src emacs-lisp
  (require-package 'git-commit-mode)
#+end_src

* OSX related tweaks
Use system Trash (needs [[http://hasseg.org/trash/][trash]])
#+begin_src emacs-lisp
  (setq delete-by-moving-to-trash t)
  (defun system-move-file-to-trash (filename)
    (shell-command (concat "trash " (shell-quote-argument filename))))
#+end_src

Input related tweaks
#+begin_src emacs-lisp
  (when *is-a-mac*
    (setq mac-command-modifier 'super)
    (setq mac-option-modifier 'meta)
    (setq mouse-wheel-scroll-amount '(0.001)))
#+end_src

* Cosmetic changes
Set default font
#+begin_src emacs-lisp
  (if *is-a-mac*
      (add-to-list 'default-frame-alist
                   '(font . "Akkurat-Mono-15"))
    (add-to-list 'default-frame-alist
                 '(font . "Akkurat-Mono-11")))
#+end_src

Set Unicode font
#+begin_src emacs-lisp
  (set-fontset-font "fontset-default" 'unicode (if *is-a-mac* "Menlo" "Symbola"))
#+end_src

Disable bold faces
#+begin_src emacs-lisp
  (mapc
   (lambda (face)
     (set-face-attribute face nil :weight 'normal :underline nil))
   (face-list))
#+end_src

Use proportional fonts in mode-line
#+begin_src emacs-lisp
  (run-at-time "0 sec" nil
               (lambda ()
                 (set-face-attribute 'mode-line nil :family "Muli")))
#+end_src

Use UTF-8 bullets on org-mode buffers
#+begin_src emacs-lisp
  (require-package 'org-bullets)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+end_src

* Misc Emacs modes
** Completion
Launch standard completion using tab
#+begin_src emacs-lisp
  (setq tab-always-indent 'complete)
  (add-to-list 'completion-styles 'initials t)
#+end_src

Exclude very large buffers from dabbrev
#+begin_src emacs-lisp
  (defun sanityinc/dabbrev-friend-buffer (other-buffer)
    (< (buffer-size other-buffer) (* 1 1024 1024)))

  (setq dabbrev-friend-buffer-function 'sanityinc/dabbrev-friend-buffer)
#+end_src
** Convenient bookmarking using bm
#+begin_src emacs-lisp
  (require-package 'bm)

  (global-set-key (kbd "<M-f2>") 'bm-toggle)
  (global-set-key (kbd "<f2>")   'bm-next)
  (global-set-key (kbd "<S-f2>") 'bm-previous)
  (global-set-key (kbd "<left-fringe> <mouse-1>") 'bm-toggle-mouse)
  (global-set-key (kbd "<left-fringe> <wheel-down>") 'bm-next-mouse)
  (global-set-key (kbd "<left-fringe> <wheel-up>") 'bm-previous-mouse)
#+end_src

** Undo-Tree
#+begin_src emacs-lisp
  (require-package 'undo-tree)
  (global-undo-tree-mode)
  (diminish 'undo-tree-mode)
#+end_src

** Browsers
#+begin_src emacs-lisp
  (require-package 'w3m)
  (setq w3m-command "/usr/local/bin/w3m")
  (setq browse-url-browser-function 'browse-url-firefox)
#+end_src

** Disable hl-line-mode
#+begin_src emacs-lisp
  (remove-hook 'prog-mode-hook 'esk-turn-on-hl-line-mode)
#+end_src

** ack-and-a-half
#+begin_src emacs-lisp
  (require-package 'ack-and-a-half)
#+end_src

Editable buffer
#+begin_src emacs-lisp
  (require 'wgrep-ack)
#+end_src

Shorter aliases
#+begin_src emacs-lisp
  (defalias 'ack 'ack-and-a-half)
  (defalias 'ack-same 'ack-and-a-half-same)
  (defalias 'ack-find-file 'ack-and-a-half-find-file)
  (defalias 'ack-find-file-same 'ack-and-a-half-find-file-same)
#+end_src

** Shell
Use fish shell
#+begin_src emacs-lisp
  (setq explicit-shell-file-name "/usr/local/bin/fish")
#+end_src

** Snippets
#+begin_src emacs-lisp
  (yas-global-mode 1)
#+end_src

*** Helper functions
Helm interface
#+begin_src emacs-lisp
  (defun shk-yas/helm-prompt (prompt choices &optional display-fn)
    "Use helm to select a snippet. Put this into `yas/prompt-functions.'"
    (interactive)
    (setq display-fn (or display-fn 'identity))
    (if (require 'helm-config)
        (let (tmpsource cands result rmap)
          (setq cands (mapcar (lambda (x) (funcall display-fn x)) choices))
          (setq rmap (mapcar (lambda (x) (cons (funcall display-fn x) x)) choices))
          (setq tmpsource
                (list
                 (cons 'name prompt)
                 (cons 'candidates cands)
                 '(action . (("Expand" . (lambda (selection) selection))))
                 ))
          (setq result (helm-other-buffer '(tmpsource) "*helm-select-yasnippet"))
          (if (null result)
              (signal 'quit "user quit!")
            (cdr (assoc result rmap))))
      nil))
  (setq yas/prompt-functions '(shk-yas/helm-prompt yas/no-prompt))
#+end_src

JavaScript [[https://github.com/magnars/.emacs.d/blob/master/defuns/snippet-helpers.el][(From here)]]
#+begin_src emacs-lisp
  (defun js-method-p ()
    (save-excursion
      (word-search-backward "function")
      (looking-back ": ")))

  (defun js-function-declaration-p ()
    (save-excursion
      (word-search-backward "function")
      (looking-back "^\\s *")))

  (defun snippet--function-punctuation ()
    (if (js-method-p)
        (when (not (looking-at "[ \n\t\r]*}"))
          (insert ","))
      (unless (js-function-declaration-p)
        (if (looking-at "$") (insert ";")))))

  (defun snippet--function-name ()
    (if (js-function-declaration-p) "name" ""))
#+end_src

** Slate configuration language
#+begin_src emacs-lisp
  (require 'slate-config-mode)
#+end_src

** EMMS
#+begin_src emacs-lisp
  (require-package 'emms)

  (autoload 'emms-browser "emms-browser"
    "Launch or switch to the EMMS Browser." t)
  (autoload 'emms "emms-playlist-mode"
    "Switch to the current emms-playlist buffer." t)

  (eval-after-load "emms"
    `(progn
       (emms-devel)
       (emms-default-players)

       (if (require 'emms-info-libtag nil t)
           (add-to-list 'emms-info-functions 'emms-info-libtag
                        nil 'eq))
       (require 'emms-mark nil t)

       (require 'emms-history)
       (emms-history-load)

       ;; swap time and other track info
       (let ((new-global-mode-string nil))
         (while (and (not (memq (car global-mode-string)
                                '(emms-mode-line-string
                                  emms-playing-time-string)))
                     global-mode-string)
           (push (car global-mode-string) new-global-mode-string)
           (setq global-mode-string (cdr global-mode-string)))
         (setq global-mode-string
               (nconc (nreverse new-global-mode-string)
                      '(emms-playing-time-string
                        emms-mode-line-string))))
       (add-hook 'emms-player-started-hook 'emms-show)


       (defun my-emms-covers (dir type)
         "Choose album cover in DIR deppending on TYPE.
          Small cover should be less than 80000 bytes.
          Medium - less than 120000 bytes."
         (let* ((pics (directory-files-and-attributes
                       dir t "\\.\\(jpe?g\\|png\\|gif\\|bmp\\)$" t))
                (pic (car pics))
                (pic-size (nth 8 pic)))
           (let (temp)
             (cond
              ((eq type 'small)
               (while (setq temp (cadr pics))
                 (let ((temp-size (nth 8 temp)))
                   (if (< temp-size pic-size)
                       (setq pic temp
                             pic-size temp-size)))
                 (setq pics (cdr pics)))
               (if (<= (or pic-size 80001) 80000)
                   (car pic)))
              ((eq type 'medium)
               (if (and pic (setq temp (cadr pics)))
                   (progn
                     (setq pics (cdr pics))
                     (let ((temp-size (nth 8 temp)))
                       (let ((small temp)
                             (small-size temp-size))
                         (if (< pic-size small-size)
                             (setq small pic
                                   small-size pic-size
                                   pic temp
                                   pic-size temp-size))
                         (while (setq temp (cadr pics))
                           (setq temp-size (nth 8 temp))
                           (cond
                            ((< temp-size small-size)
                             (setq pic small
                                   pic-size small-size
                                   small temp
                                   small-size temp-size))
                            ((< temp-size pic-size)
                             (setq pic temp
                                   pic-size temp-size)))
                           (setq pics (cdr pics)))
                         (car (if (<= pic-size 120000) pic
                                small)))))
                 (car pic)))
              ((eq type 'large)
               (while (setq temp (cadr pics))
                 (let ((temp-size (nth 8 temp)))
                   (if (> temp-size pic-size)
                       (setq pic temp
                             pic-size temp-size)))
                 (setq pics (cdr pics)))
               (car pic))))))

       (setq emms-show-format "🎵 %s"
             emms-mode-line-format "%s"
             emms-playing-time-display-format "🎵 %s "
             emms-source-file-default-directory "~/Music"
             emms-browser-covers 'my-emms-covers)

       ;; lastfm
       (when (and (load-secrets)
                  (require 'emms-lastfm-scrobbler nil t)
                  (let ((url-request-method "GET"))
                    (ignore-errors        ; check for internet connection
                      (url-retrieve-synchronously
                       "http://post.audioscrobbler.com"))))
         (condition-case err
             (emms-lastfm-scrobbler-enable)
           (error (message "No scrobbling: %s" err))))

       (require 'emms-player-mplayer)
       (define-emms-simple-player mplayer '(file url)
         (regexp-opt '(".ogg" ".mp3" ".wav" ".mpg" ".mpeg" ".wmv" ".wma"
                       ".mov" ".avi" ".divx" ".ogm" ".asf" ".mkv" "http://" "mms://"
                       ".rm" ".rmvb" ".mp4" ".flac" ".vob" ".m4a" ".flv" ".ogv" ".pls"))
         "mplayer" "-slave" "-quiet" "-really-quiet" "-fullscreen")

       (require 'emms-info-metaflac)
       (add-to-list 'emms-info-functions 'emms-info-metaflac nil 'eq)

       (global-set-key "\C-cp" 'emms-pause)

       (setq emms-player-next-function
             (lambda () "Notify on new track."
               (emms-next-noerror)
               (if emms-player-playing-p
                   (todochiku-message
                    "EMMS"
                    (concat "🎵 "
                            (emms-track-description
                             (emms-playlist-current-selected-track)))
                    (todochiku-icon 'music)))))

       ;; track info ticker
       (defun string-shift-left (str &optional offset)
         "Shift STR content to the left OFFSET characters."
         (or offset (setq offset 1))
         (let ((str-len (length str)))
           (if (< offset str-len)
               (concat (substring-no-properties str offset)
                       (substring-no-properties str 0 offset))
             str)))

       (defun emms-tick-mode-line-description (offset)
         "Tick emms track description OFFSET characters."
         (setq emms-mode-line-string
               (string-shift-left emms-mode-line-string offset)))

       (defvar *my-emms-ticker* nil
         "Timer for current track info ticker.")

       (defun emms-track-ticker-start ()
         "Start ticking current TRACK info."
         (or *my-emms-ticker*
             (setq *my-emms-ticker*
                   (run-at-time t 2
                                'emms-tick-mode-line-description 5))))

       (defun emms-track-ticker-stop ()
         "Stop ticking current TRACK info."
         (when *my-emms-ticker*
           (cancel-timer *my-emms-ticker*)
           (setq *my-emms-ticker* nil)))


       (add-hook 'emms-player-started-hook 'emms-track-ticker-start)
       (add-hook 'emms-player-stopped-hook 'emms-track-ticker-stop)
       (add-hook 'emms-player-finished-hook 'emms-track-ticker-stop)
       (add-hook 'emms-player-paused-hook
                 (lambda () "Start/Stop track ticker."
                   (if *my-emms-ticker*
                       (emms-track-ticker-stop)
                     (emms-track-ticker-start))))))
#+end_src
* Misc keybindings
** Quick way to open a link
#+begin_src emacs-lisp
  (global-set-key "\C-cb" 'org-open-at-point-global)
#+end_src

* Misc tweaks
No bell whatsoever please
#+begin_src emacs-lisp
  (setq visual-bell nil)
  (setq ring-bell-function 'ignore)
#+end_src

Disable autopair in some modes
#+begin_src emacs-lisp
  (add-hook 'erc-mode-hook 'inhibit-autopair)
  (add-hook 'term-mode-hook 'inhibit-autopair)
#+end_src

Disable show-trailing-whitespace in some modes
#+begin_src emacs-lisp
  (dolist (hook '(erc-mode-hook
                  term-mode-hook
                  eshell-mode-hook
                  nrepl-mode-hook
                  inferior-python-mode-hook
                  inferior-emacs-lisp-mode
                  helm-update-hook
                  slime-repl-mode-hook
                  mu4e-main-mode-hook
                  mu4e-headers-mode-hook
                  mu4e-view-mode-hook
                  jabber-roster-mode-hook
                  jabber-chat-mode-hook
                  jabber-browse-mode-hook))
    (add-hook hook (lambda () (setq show-trailing-whitespace nil))))
#+end_src

Disable yasnippet in some modes
#+begin_src emacs-lisp
  (add-hook 'term-mode-hook (lambda()
                  (yas-minor-mode -1)))
#+end_src

Wrap lines longer than 79 characters
#+begin_src emacs-lisp
  (setq-default fill-column 79)
#+end_src

Set tmp dir to ~/.emacs.d/tmp
#+begin_src emacs-lisp
  (setq temporary-file-directory "~/.emacs.d/tmp/")

  (make-directory temporary-file-directory t)

  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t)))
#+end_src

Cleanup buffers before saving
#+begin_src emacs-lisp
  (defun untabify-buffer ()
    (interactive)
    (untabify (point-min) (point-max)))

  (defun indent-buffer ()
    (interactive)
    (indent-region (point-min) (point-max)))

  (defun cleanup-buffer-safe ()
    "Perform a bunch of safe operations on the whitespace content of a buffer.
  Does not indent buffer, because it is used for a before-save-hook, and that
  might be bad."
    (interactive)
    (delete-trailing-whitespace)
    (set-buffer-file-coding-system 'utf-8))

  (defun cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer.
  Including indent-buffer, which should not be called automatically on save."
    (interactive)
    (cleanup-buffer-safe)
    (untabify-buffer)
    (indent-buffer))

  (add-hook 'before-save-hook 'cleanup-buffer-safe)

  (global-set-key (kbd "C-c n") 'cleanup-buffer)
  (global-set-key (kbd "C-c C-<return>") 'delete-blank-lines)
#+end_src
