#+TITLE: Ozan Sener's Emacs configuration
#+OPTIONS: toc:nil num:nil ^:nil
* Load some lisp
#+begin_src emacs-lisp
  (require 'cl)
#+end_src

** Install some additional packages
#+begin_src emacs-lisp
  (require-package 'starter-kit-bindings)
  (require-package 'ack-and-a-half)
  (require-package 'bm)
  (require-package 'undo-tree)
  (require-package 'popwin)
  (require-package 'smartrep)
  (require-package 'erc-hl-nicks)
  (require-package 'helm)
  (require-package 'w3m)
  (require-package 'python '(20120814))
  (require-package 'python-pep8)
  (require-package 'python-pylint)
  (require-package 'virtualenv)
  (require-package 'yasnippet)
  (require-package 'slime-js)
  (require-package 'textmate)
  (require-package 'peepopen)
  (require-package 'powerline)
#+end_src

* Programming languages
** Scheme
#+begin_src emacs-lisp
  (add-hook 'scheme-mode-hook 'sanityinc/lisp-setup)
#+end_src
*** Chicken Scheme
Load chicken
#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/local/lib/chicken/6/")
  (autoload 'chicken-slime "chicken-slime" "SWANK backend for Chicken" t)
  (add-hook 'scheme-mode-hook
            (lambda ()
              (slime-mode t)))
#+end_src
** Clojure
Static checking using kibit
#+begin_src emacs-lisp
  (require 'compile)
  (add-to-list 'compilation-error-regexp-alist-alist
               '(kibit "At \\([^:]+\\):\\([[:digit:]]+\\):" 1 2 nil 0))
  (add-to-list 'compilation-error-regexp-alist 'kibit)

  ;; A convenient command to run "lein kibit" in the project to which
  ;; the current emacs buffer belongs to.
  (defun kibit ()
    "Run kibit on the current project.
  Display the results in a hyperlinked *compilation* buffer."
    (interactive)
    (compile "lein kibit"))
#+end_src
** Python
*** Python.el ipython integration
Code completion
#+begin_src emacs-lisp
  (setq python-shell-interpreter "ipython"
        python-shell-interpreter-args ""
        python-shell-prompt-regexp "In \\[[0-9]+\\]: "
        python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
        python-shell-completion-setup-code
        "from IPython.core.completerlib import module_completion"
        python-shell-completion-module-string-code
        "';'.join(module_completion('''%s'''))\n"
        python-shell-completion-string-code
        "';'.join(get_ipython().Completer.all_completions('''%s'''))\n")
#+end_src
*** Auto-indentation
#+begin_src emacs-lisp
  (add-hook 'python-mode-hook
    #'(lambda ()
        (define-key python-mode-map "\C-m" 'newline-and-indent)))
#+end_src
** C
Auto indentation (C-j is harder to reach on Colemak)
#+begin_src emacs-lisp
  (add-hook 'c-mode-common-hook '(lambda ()
        (local-set-key (kbd "RET") 'newline-and-indent)))
#+end_src
** Javascript
*** Set up Slime with swank-js
#+begin_src emacs-lisp
  (autoload 'slime-fuzzy-init "slime-fuzzy" "" nil)
  (eval-after-load 'slime-fuzzy
    '(require 'slime-repl))

  (eval-after-load 'slime
    '(progn
       (setq slime-protocol-version 'ignore)
       (setq slime-net-coding-system 'utf-8-unix)
       (slime-setup '(slime-repl slime-js helm-slime))
       (setq slime-complete-symbol-function 'helm-slime-complete)))

  (defun set-up-slime-js ()
    (require 'slime)
    (slime-js-minor-mode 1)
    (global-set-key [f5] 'slime-js-reload))

  (add-hook 'js3-mode-hook 'set-up-slime-js)
#+end_src

*** Insert semicolons automatically
#+begin_src emacs-lisp
  (require 'js3-mode)
  (defvar js3-semicolon-contexts
    (list js3-NAME js3-LP js3-SCRIPT js3-CALL js3-BLOCK))
  (defun autopair-js3-maybe-insert-semi-colon (action pair pos-before)
    "handler for automatically inserting semi-colon at the end of function call."
    (cond ((and (eq action 'opening)
                (eq pair ?\))
                (save-excursion
                  (goto-char pos-before)
                  (skip-chars-backward " \t")
                  (memq (js3-node-type (js3-node-at-point (point)))
                        js3-semicolon-contexts)
                  ))
           (save-excursion
             (let ((forward-sexp-function nil))
               (goto-char pos-before)
               (forward-sexp))
             (if (looking-at-p "[^[:graph:]]*$")
                 (insert ";"))))))

  (add-hook 'js3-mode-hook
            '(lambda ()
               (setq autopair-handle-action-fns
                     (list #'autopair-default-handle-action
                           #'autopair-js3-maybe-insert-semi-colon))))
#+end_src

*** Syntax checking with jshint
#+begin_src emacs-lisp
  (require 'flymake-jshint)
  (dolist (hook '(js2-mode-hook js3-mode-hook js-mode-hook))
    (add-hook hook (lambda () (flymake-mode t))))
#+end_src
*** json-mode
#+begin_src emacs-lisp
  (require 'json-mode)
  (add-to-list 'auto-mode-alist '("\\.json$" . json-mode))
#+end_src
* Eshell
Great intro post for eshell, also the source of some of these settings:
http://www.masteringemacs.org/articles/2010/12/13/complete-guide-mastering-eshell/

** Change some defaults
#+begin_src emacs-lisp
  (eval-after-load 'esh-opt
    '(progn
       (require 'em-prompt)
       (setq eshell-cmpl-ignore-case t)
       (setq eshell-prefer-lisp-functions t)
       (setq eshell-where-to-jump 'begin)
       (setq eshell-review-quick-commands nil)
       (setq eshell-smart-space-goes-to-end t)
       (setq eshell-directory-name
             (expand-file-name "./" (expand-file-name "eshell" "~/.emacs.d")))))
#+end_src

** Convenience function for usage in a terminal emulator
This allows you to use eshell in a similar fashion to standard Unix
shells in a terminal emulator.

Call Emacs like this for an one-off eshell buffer:
emacsclient -a '' -t -e "(server-eshell)"
#+begin_src emacs-lisp
  (defun server-eshell ()
    "Command to be called by emacs-client to start a new shell.

  A new eshell will be created. When the frame is closed, the buffer is
  deleted or the shell exits, then hooks will take care that the other
  actions happen. For example, when the frame is closed, then the buffer
  will be deleted and the client disconnected.

  Also creates a local binding of 'C-x #' to kill the buffer."
    (lexical-let ((buf (eshell t))
                  (client (first server-clients))
                  (frame (selected-frame)))
      (labels ((close (&optional arg)
                      (when (not (boundp 'cve/recurse))
                        (let ((cve/recurse t))
                          (delete-frame frame)
                          (kill-buffer buf)
                          (server-delete-client client)))))
        (add-hook 'eshell-exit-hook #'close t t)
        (add-hook 'delete-frame-functions #'close t t))
      (local-set-key (kbd "C-x #") (lambda () (interactive) (kill-buffer buf)))
      (delete-other-windows)
      nil))
#+end_src

** Quake-like eshell window
#+begin_src emacs-lisp
  (require 'shell-pop)
  (shell-pop-set-internal-mode "eshell")
  (global-set-key [f8] 'shell-pop)
#+end_src

** Easy way to open eshell in the directory of current buffer
[[https://github.com/technomancy/emacs-starter-kit/commit/c0e568d3c9940c9dd5241e4b49467723590fc2c2][From here]]
#+begin_src
(defun eshell-in-dir (&optional prompt)
  "Change the directory of an existing eshell to the directory of the file in
the current buffer or launch a new eshell if one isn't running. If the
current buffer does not have a file (e.g., a *scratch* buffer) launch or raise
eshell, as appropriate. Given a prefix arg, prompt for the destination
directory."
  (interactive "P")
  (let* ((original-buffer (current-buffer))
         (name (buffer-file-name))
         (dir (cond (prompt (read-directory-name "Directory: " nil nil t))
                    (name (file-name-directory name))
                    (t nil)))
         (buffers (delq nil (mapcar (lambda (buf)
                                      (with-current-buffer buf
                                        (when (eq 'eshell-mode major-mode)
                                          (buffer-name))))
                                    (buffer-list))))
         (buffer (cond ((eq 1 (length buffers)) (first buffers))
                       ((< 1 (length buffers)) (ido-completing-read
                                                "Eshell buffer: " buffers nil t
                                                nil nil (first buffers)))
                       (t (eshell)))))
    (with-current-buffer buffer
      (when dir
        (eshell/cd (list dir))
        (eshell-send-input))
      (end-of-buffer)
      (switch-to-buffer original-buffer)
      (shell-pop-up))))
#+end_src

** Clickable ls output
[[http://www.emacswiki.org/emacs/EshellEnhancedLS][From EmacsWiki]]
#+begin_src emacs-lisp
  (eval-after-load "em-ls"
    '(progn
       (defun ted-eshell-ls-find-file-at-point (point)
         "RET on Eshell's `ls' output to open files."
         (interactive "d")
         (find-file
          (replace-regexp-in-string
           "[ \t\n]*$" ""
           (replace-regexp-in-string
            "^[ \t\n]*" ""
            (buffer-substring-no-properties
             (previous-single-property-change point 'help-echo)
             (next-single-property-change point 'help-echo))))))

       (defun pat-eshell-ls-find-file-at-mouse-click (event)
         "Middle click on Eshell's `ls' output to open files.
   From Patrick Anderson via the wiki."
         (interactive "e")
         (ted-eshell-ls-find-file-at-point (posn-point (event-end event))))

       (let ((map (make-sparse-keymap)))
         (define-key map (kbd "RET")      'ted-eshell-ls-find-file-at-point)
         (define-key map (kbd "<return>") 'ted-eshell-ls-find-file-at-point)
         (define-key map (kbd "<mouse-2>") 'pat-eshell-ls-find-file-at-mouse-click)
         (defvar ted-eshell-ls-keymap map))

       (defadvice eshell-ls-decorated-name (after ted-electrify-ls activate)
         "Eshell's `ls' now lets you click or RET on file names to open them."
         (add-text-properties 0 (length ad-return-value)
                              (list 'help-echo "RET, mouse-2: visit this file"
                                    'mouse-face 'highlight
                                    'keymap ted-eshell-ls-keymap)
                              ad-return-value)
         ad-return-value)))
#+end_src

** Colorize prompt on nonzero exit codes
#+begin_src emacs-lisp
  (defface esk-eshell-error-prompt-face
    '((((class color) (background dark)) (:foreground "red" :bold t))
      (((class color) (background light)) (:foreground "red" :bold t)))
    "Face for nonzero prompt results"
    :group 'eshell-prompt)

  (add-hook 'eshell-after-prompt-hook
            (defun esk-eshell-exit-code-prompt-face ()
              (when (and eshell-last-command-status
                         (not (zerop eshell-last-command-status)))
                (let ((inhibit-read-only t))
                  (add-text-properties
                   (save-excursion (beginning-of-line) (point)) (point-max)
                   '(face esk-eshell-error-prompt-face))))))
#+end_src

** Misc commands
#+begin_src emacs-lisp
  (defun eshell/cds ()
    "Change directory to the project's root."
    (eshell/cd (locate-dominating-file default-directory "src")))

  (defun eshell/cdl ()
    "Change directory to the project's root."
    (eshell/cd (locate-dominating-file default-directory "lib")))

  (defun eshell/cdg ()
    "Change directory to the project's root."
    (eshell/cd (locate-dominating-file default-directory ".git")))
#+end_src

* Window management
** Popwin
#+begin_src emacs-lisp
  (require 'popwin)
  (setq display-buffer-function 'popwin:display-buffer)

  (setq popwin:special-display-config
        '(("*Help*" :height 30 :stick t)
          ("*Completions*" :noselect t)
          ("*compilation*" :noselect t)
          ("*Messages*" :height 30)
          ("*Occur*" :noselect t)
          ("*Directory*" :noselect t)
          ("*Packages*" :height 30)
          ("*ack-and-a-half*" :noselect t)
          ("\\*Slime Description.*" :noselect t :regexp t :height 30)
          ("*magit-commit*" :noselect t :height 40 :width 80)
          ("*magit-diff*" :noselect t :height 40 :width 80)
          ("*magit-edit-log*" :noselect t :height 15 :width 80)
          ("\\*Slime Inspector.*" :regexp t :height 30)
          ("*Ido Completions*" :noselect t :height 30)
          ("\\*ansi-term\\*.*" :regexp t :height 30)
          ("*shell*" :height 30)
          ("*gists*" :height 30)
          ("*sldb.*":regexp t :height 30)))
#+end_src
* Email
Mu4e (http://www.djcbsoftware.nl/code/mu/) is e great mail reader.
#+begin_src sh
  brew install offlineimap
  brew install mu --with-emacs
#+end_src

#+begin_src emacs-lisp
  (require 'mu4e)

  (setq mu4e-drafts-folder "/[Gmail].Drafts")
  (setq mu4e-sent-folder   "/[Gmail].Sent Mail")
  (setq mu4e-trash-folder  "/[Gmail].Trash")

  ;; don't save message to Sent Messages, Gmail/IMAP will take care of this
  (setq mu4e-sent-messages-behavior 'delete)

  (setq mu4e-html2text-command "w3m -dump")

  ;; setup some handy shortcuts
  (setq mu4e-maildir-shortcuts
        '( ("/INBOX"               . ?i)
           ("/[Gmail].Sent Mail"   . ?s)
           ("/[Gmail].Trash"       . ?t)
           ("/[Gmail].All Mail"    . ?a)))

  ;; allow for updating mail using 'U' in the main view:
  (setq mu4e-get-mail-command "offlineimap")

  ;; something about ourselves
  (setq
   user-mail-address "ozan@ozansener.com"
   user-full-name  "Ozan Sener"
   message-signature
   (concat
    "Ozan Sener\n"
    "http://ozansener.com\n"))

  (setq mail-user-agent 'mu4e-user-agent)
#+end_src

Send mail using smtpmail-async
#+begin_src emacs-lisp
  ;; make sure the gnutls command line utils are installed
  ;; package 'gnutls-bin' in Debian/Ubuntu

  (autoload 'async-smtpmail-send-it "smtpmail-async")
  (setq message-send-mail-function 'async-smtpmail-send-it
        smtpmail-stream-type 'starttls
        starttls-use-gnutls t
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587)

  ;; don't keep message buffers around
  (setq message-kill-buffer-on-exit t)
#+end_src

* ERC
** Disable trailing whitespace in ERC buffers
#+begin_src emacs-lisp
  (add-hook 'erc-mode-hook (lambda ()
                                (setq show-trailing-whitespace nil)))
#+end_src

** Growl notifications
#+begin_src emacs-lisp
  (defun my-erc-hook (match-type nick message)
    "Shows a growl notification, when user's nick was mentioned. If the buffer is currently not visible, makes it sticky."
    (unless (posix-string-match "^\\** *Users on #" message)
      (todochiku-message
       "ERC"
       (concat "Name mentioned on: " (buffer-name (current-buffer)))
       (todochiku-icon 'irc))))
  (add-hook 'erc-text-matched-hook 'my-erc-hook)
#+end_src
** ZNC
#+begin_src emacs-lisp
  (require 'znc)
#+end_src
* Helm
#+begin_src emacs-lisp
  (require 'helm-config)
#+end_src

Eshell completion
#+begin_src emacs-lisp
  (require 'helm-files)

  (add-hook 'eshell-mode-hook
            #'(lambda ()
                (define-key eshell-mode-map
                  (kbd "M-p")
                  'helm-eshell-history)))
#+end_src

Ipython completion
#+begin_src emacs-lisp
  (require 'helm-ipython)
  (define-key python-mode-map (kbd "M-<tab>")
    'helm-ipython-complete)
#+end_src

Elisp completion
#+begin_src emacs-lisp
  (define-key emacs-lisp-mode-map (kbd "M-<tab>")
    'helm-lisp-completion-at-point)
#+end_src

JavaScript completion
#+begin_src emacs-lisp
  (define-key js3-mode-map (kbd "M-<tab>")
    'helm-slime-complete)
#+end_src

Keybindings
#+begin_src emacs-lisp
  (global-set-key (kbd "<f1>") 'helm-mini)
#+end_src

* OSX related tweaks
** Use system Trash
Uses [[http://hasseg.org/trash/][trash]]
#+begin_src emacs-lisp
  (when *is-a-mac*
    (setq delete-by-moving-to-trash t)
    (defun system-move-file-to-trash (filename)
      (shell-command (concat "trash " (shell-quote-argument filename)))))
#+end_src

** Input related tweaks
#+begin_src emacs-lisp
  (when *is-a-mac*
    (setq mac-command-modifier 'super)
    (setq mac-option-modifier 'meta)
    (setq mouse-wheel-scroll-amount '(0.001)))
#+end_src

** Add a shortcut for toggling fullscreen mode in Cocoa Emacs
#+begin_src emacs-lisp
(when *is-cocoa-emacs*
  (global-set-key [f11] 'ns-toggle-fullscreen))
#+end_src

** PeepOpen
#+begin_src emacs-lisp
  (when *is-a-mac*
    (textmate-mode)
    (diminish 'textmate-mode)
    (define-key *textmate-mode-map* [(super t)] 'peepopen-goto-file-gui))
#+end_src

* Cosmetic changes
** Set default font
#+begin_src emacs-lisp
  (if *is-a-mac*
      (add-to-list 'default-frame-alist
                   '(font . "Akkurat-Mono-14"))
    (add-to-list 'default-frame-alist
                 '(font . "Akkurat-Mono-12")))
#+end_src

** Set Unicode font
#+begin_src emacs-lisp
  (set-fontset-font "fontset-default" 'unicode "Menlo")
#+end_src

** Disable bold faces
#+begin_src emacs-lisp
  (mapc
   (lambda (face)
     (set-face-attribute face nil :weight 'normal :underline nil))
   (face-list))
#+end_src

** Fancy mode line
#+begin_src emacs-lisp
  (powerline-default)
#+end_src

* Misc Emacs modes
** Completion
Launch standard completion using tab
#+begin_src emacs-lisp
  (setq tab-always-indent 'complete)
  (add-to-list 'completion-styles 'initials t)
#+end_src

Exclude very large buffers from dabbrev
#+begin_src emacs-lisp
  (defun sanityinc/dabbrev-friend-buffer (other-buffer)
    (< (buffer-size other-buffer) (* 1 1024 1024)))

  (setq dabbrev-friend-buffer-function 'sanityinc/dabbrev-friend-buffer)
#+end_src
** Convenient bookmarking using bm
#+begin_src emacs-lisp
(global-set-key (kbd "<C-f2>") 'bm-toggle)
(global-set-key (kbd "<f2>")   'bm-next)
(global-set-key (kbd "<S-f2>") 'bm-previous)
(global-set-key (kbd "<left-fringe> <mouse-1>") 'bm-toggle-mouse)
(global-set-key (kbd "<left-fringe> <wheel-down>") 'bm-next-mouse)
(global-set-key (kbd "<left-fringe> <wheel-up>") 'bm-previous-mouse)
#+end_src

** Undo-Tree
#+begin_src emacs-lisp
  (global-undo-tree-mode)
  (diminish 'undo-tree-mode)
#+end_src

** Browsers
#+begin_src emacs-lisp
  (setq browse-url-browser-function 'browse-url-firefox)
  (setq w3m-command "/usr/local/bin/w3m")

#+end_src

** Disable hl-line-mode
#+begin_src emacs-lisp
  (remove-hook 'prog-mode-hook 'esk-turn-on-hl-line-mode)
#+end_src

** ack-and-a-half
Editable buffer
#+begin_src emacs-lisp
  (require 'wgrep-ack)
#+end_src

Shorter aliases
#+begin_src emacs-lisp
  (defalias 'ack 'ack-and-a-half)
  (defalias 'ack-same 'ack-and-a-half-same)
  (defalias 'ack-find-file 'ack-and-a-half-find-file)
  (defalias 'ack-find-file-same 'ack-and-a-half-find-file-same)
#+end_src

** Shell
Use fish shell
#+begin_src emacs-lisp
  (setq explicit-shell-file-name "/usr/local/bin/fish")
#+end_src

** Snippets
#+begin_src emacs-lisp
  (yas-global-mode 1)
#+end_src

*** Helper functions
Helm interface
#+begin_src emacs-lisp
  (defun shk-yas/helm-prompt (prompt choices &optional display-fn)
    "Use helm to select a snippet. Put this into `yas/prompt-functions.'"
    (interactive)
    (setq display-fn (or display-fn 'identity))
    (if (require 'helm-config)
        (let (tmpsource cands result rmap)
          (setq cands (mapcar (lambda (x) (funcall display-fn x)) choices))
          (setq rmap (mapcar (lambda (x) (cons (funcall display-fn x) x)) choices))
          (setq tmpsource
                (list
                 (cons 'name prompt)
                 (cons 'candidates cands)
                 '(action . (("Expand" . (lambda (selection) selection))))
                 ))
          (setq result (helm-other-buffer '(tmpsource) "*helm-select-yasnippet"))
          (if (null result)
              (signal 'quit "user quit!")
            (cdr (assoc result rmap))))
      nil))
  (setq yas/prompt-functions '(shk-yas/helm-prompt yas/no-prompt))
#+end_src

JavaScript [[https://github.com/magnars/.emacs.d/blob/master/defuns/snippet-helpers.el][(From here)]]
#+begin_src emacs-lisp
  (defun js-method-p ()
    (save-excursion
      (word-search-backward "function")
      (looking-back ": ")))

  (defun js-function-declaration-p ()
    (save-excursion
      (word-search-backward "function")
      (looking-back "^\\s *")))

  (defun snippet--function-punctuation ()
    (if (js-method-p)
        (when (not (looking-at "[ \n\t\r]*}"))
          (insert ","))
      (unless (js-function-declaration-p)
        (if (looking-at "$") (insert ";")))))

  (defun snippet--function-name ()
    (if (js-function-declaration-p) "name" ""))
#+end_src

* Misc keybindings
** Quick way to open a link
#+begin_src emacs-lisp
  (global-set-key "\C-cb" 'org-open-at-point-global)
#+end_src

* Misc tweaks
** No bell whatsoever please
#+begin_src emacs-lisp
  (setq visual-bell nil)
  (setq ring-bell-function 'ignore)
#+end_src
** Enable menubar explicitly
#+begin_src emacs-lisp
  (menu-bar-mode t)
#+end_src
** Disable autopair in some modes
#+begin_src emacs-lisp
  (add-hook 'erc-mode-hook 'inhibit-autopair)
  (add-hook 'term-mode-hook 'inhibit-autopair)
#+end_src

** Disable show-trailing-whitespace in some modes
#+begin_src emacs-lisp
  (dolist (hook '(erc-mode-hook
                  term-mode-hook
                  eshell-mode-hook
                  nrepl-mode-hook
                  inferior-python-mode-hook
                  helm-update-hook
                  slime-repl-mode-hook))
    (add-hook hook (lambda () (setq show-trailing-whitespace nil))))
#+end_src

** Wrap lines longer than 79 characters
#+begin_src emacs-lisp
  (setq-default fill-column 79)
#+end_src
