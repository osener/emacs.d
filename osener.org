#+TITLE: Ozan Sener's Emacs configuration
#+OPTIONS: num:nil ^:nil
* Load some lisp
#+BEGIN_SRC emacs-lisp
  (require 'cl)
#+END_SRC

Install some additional packages
#+BEGIN_SRC emacs-lisp
  (require-package 'starter-kit-bindings)
  (require-package 'yasnippet)
  (require-package 'jade-mode)
  (require-package 'dash)
  (require-package 'multiple-cursors)
  (require-package 'async)
  (require-package 'restclient)
  (require-package 'typo)
  (require-package 'dic-lookup-w3m)
  (require-package 'protobuf-mode)
#+END_SRC

* Programming languages
** Scheme
#+BEGIN_SRC emacs-lisp
  (add-hook 'scheme-mode-hook 'sanityinc/lisp-setup)
#+END_SRC
*** Chicken Scheme
Load chicken
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "/usr/local/lib/chicken/6/")
  (autoload 'chicken-slime "chicken-slime" "SWANK backend for Chicken" t)
  (add-hook 'scheme-mode-hook
            (lambda ()
              (slime-mode t)))
#+END_SRC

** Clojure
#+BEGIN_SRC emacs-lisp
  (require-package 'lein)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (require-package 'clj-refactor)

  (add-hook 'clojure-mode-hook
            (lambda ()
              (clj-refactor-mode 1)
              (cljr-add-keybindings-with-prefix "C-c C-m")))
#+END_SRC
*** Testing & static analysis
Static checking using kibit
#+BEGIN_SRC emacs-lisp
  (require 'compile)
  (add-to-list 'compilation-error-regexp-alist-alist
               '(kibit "At \\([^:]+\\):\\([[:digit:]]+\\):" 1 2 nil 0))
  (add-to-list 'compilation-error-regexp-alist 'kibit)

  ;; A convenient command to run "lein kibit" in the project to which
  ;; the current emacs buffer belongs to.
  (defun kibit ()
    "Run kibit on the current project.
  Display the results in a hyperlinked *compilation* buffer."
    (interactive)
    (compile "lein kibit"))
#+END_SRC

 Midje mode
#+BEGIN_SRC emacs-lisp
  (require-package 'midje-mode)
  (require 'clojure-jump-to-file)
#+END_SRC

*** Nrepl
Display colors in nrepl buffers
#+BEGIN_SRC emacs-lisp
  (defun nrepl-emit-output (buffer string &optional bol)
    "Using BUFFER, emit STRING.
    If BOL is non-nil, emit at the beginning of the line."
    (with-current-buffer buffer
      (nrepl-emit-output-at-pos buffer string nrepl-input-start-mark bol)
      (ansi-color-apply-on-region (marker-position nrepl-output-start) (point-max))))
#+END_SRC

Specify the print length to be 100 to stop infinite sequences killing things.
#+BEGIN_SRC emacs-lisp
  (defun live-nrepl-set-print-length ()
    (cider-send-string-sync "(set! *print-length* 100)" "clojure.core"))

  (add-hook 'cider-connected-hook 'live-nrepl-set-print-length)
#+END_SRC

Use persistent REPL history
#+BEGIN_SRC emacs-lisp
  (setq cider-history-file (expand-file-name ".cider-history"
                                             user-emacs-directory))
#+END_SRC

*** Datomic
Load snippets for datomic
#+BEGIN_SRC emacs-lisp
  (require-package 'datomic-snippets)
  (require 'datomic-snippets)
#+END_SRC

*** Cosmetic
Highlight expression on eval
#+BEGIN_SRC emacs-lisp
  (require-package 'highlight)
  (require-package 'nrepl-eval-sexp-fu)
  (require 'nrepl-eval-sexp-fu)
  (setq nrepl-eval-sexp-fu-flash-duration 0.3)
  (set-face-attribute 'nrepl-eval-sexp-fu-flash nil :background "#103050")
#+END_SRC

Fancy literals (from emacs-live)
#+BEGIN_SRC emacs-lisp
(eval-after-load 'clojure-mode
  '(font-lock-add-keywords
    'clojure-mode `(("(\\(fn\\)[\[[:space:]]"
                     (0 (progn (compose-region (match-beginning 1)
                                               (match-end 1) "Î»")
                               nil))))))

(eval-after-load 'clojure-mode
  '(font-lock-add-keywords
    'clojure-mode `(("\\(#\\)("
                     (0 (progn (compose-region (match-beginning 1)
                                               (match-end 1) "Æ’")
                               nil))))))

(eval-after-load 'clojure-mode
  '(font-lock-add-keywords
    'clojure-mode `(("\\(#\\){"
                     (0 (progn (compose-region (match-beginning 1)
                                               (match-end 1) "âˆˆ")
                               nil))))))
#+END_SRC

Highlight sexp
#+BEGIN_SRC emacs-lisp
  (dolist (hook (mapcar #'derived-mode-hook-name sanityinc/lispy-modes))
    (add-hook hook 'hl-sexp-mode))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp
  (require-package 'virtualenv)
  (require-package 'python-pep8)
  (require-package 'python-pylint)
#+END_SRC

Code completion using IPython
#+BEGIN_SRC emacs-lisp
  (setq python-shell-interpreter "ipython"
        python-shell-interpreter-args ""
        python-shell-prompt-regexp "In \\[[0-9]+\\]: "
        python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
        python-shell-completion-setup-code
        "from IPython.core.completerlib import module_completion"
        python-shell-completion-module-string-code
        "';'.join(module_completion('''%s'''))\n"
        python-shell-completion-string-code
        "';'.join(get_ipython().Completer.all_completions('''%s'''))\n")
#+END_SRC

Auto-indentation
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook
    #'(lambda ()
        (define-key python-mode-map "\C-m" 'newline-and-indent)))
#+END_SRC

** C/C++
Auto indentation (C-j is harder to reach on Colemak)
#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-common-hook '(lambda ()
        (local-set-key (kbd "RET") 'newline-and-indent)))
#+END_SRC

Style
#+BEGIN_SRC emacs-lisp
  (setq-default
   c-default-style "bsd"
   tab-width 4
   c-indent-level 4
   c-basic-offset 4)
#+END_SRC
** Javascript
#+BEGIN_SRC emacs-lisp
  (setq js2-concat-multiline-strings 'eol
        js2-rebind-eol-bol-keys t
        js2-idle-timer-delay 0.1
        js2-strict-inconsistent-return-warning nil
        js2-basic-offset 4)
#+END_SRC

*** Declare globals
#+BEGIN_SRC emacs-lisp
  (setq-default js2-global-externs '("module" "require" "jQuery"
                                     "$" "_" "buster" "assert"
                                     "setTimeout" "clearTimeout"
                                     "setInterval" "clearInterval"
                                     "__dirname" "console" "JSON"
                                     "cengiz"))


  ;; After js2 has parsed a js file, we look for jslint globals decl comment
  ;; ("/* global Fred, _, Harry */") and add any symbols to a buffer-local var of
  ;; acceptable global vars Note that we also support the "symbol: true" way of
  ;; specifying names via a hack (remove any ":true" to make it look like a plain
  ;; decl, and any ':false' are left behind so they'll effectively be ignored as
  ;; you can't have a symbol called "someName:false"
  (add-hook 'js2-post-parse-callbacks
            (lambda ()
              (when (> (buffer-size) 0)
                (let ((btext (replace-regexp-in-string
                              ": *true" " "
                              (replace-regexp-in-string "[\n\t ]+" " " (buffer-substring-no-properties 1 (buffer-size)) t t))))
                  (mapc (apply-partially 'add-to-list 'js2-additional-externs)
                        (split-string
                         (if (string-match "/\\* *global *\\(.*?\\) *\\*/" btext) (match-string-no-properties 1 btext) "")
                         " *, *" t))
                  ))))
#+END_SRC
*** Insert semicolons automatically
#+BEGIN_SRC emacs-lisp
  (require 'js2-mode)
  (defvar js2-semicolon-contexts
    (list js2-NAME js2-LP js2-SCRIPT js2-CALL js2-BLOCK))
  (defun sp-js2-maybe-insert-semicolon (id action context)
    (when (and (eq action 'insert)
               (save-excursion
                 (goto-char (- (point) 1))
                 (skip-chars-backward " \t")
                 (memq (js2-node-type (js2-node-at-point (point)))
                       js2-semicolon-contexts)))
      (save-excursion
        (let ((forward-sexp-function nil))
          (goto-char (- (point) 1))
          (forward-sexp))
        (if (looking-at-p "[^[:graph:]]*$")
            (insert ";")))))

  (sp-local-pair 'js2-mode "(" nil :post-handlers
                 '(:add sp-js2-maybe-insert-semicolon))
#+END_SRC

*** json-mode
#+BEGIN_SRC emacs-lisp
  (require-package 'json-mode)
  (add-to-list 'auto-mode-alist '("\\.json$" . json-mode))
#+END_SRC
*** Use lambda for anonymous functions
#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords
   'js2-mode `(("\\(function\\) *\\*?("
                (0 (progn (compose-region (match-beginning 1)
                                          (match-end 1) "\u0192")
                          nil)))))
#+END_SRC
*** Use right arrow for return in one-line functions
#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords
   'js2-mode `(("function *([^)]*) *{ *\\(return\\) "
                (0 (progn (compose-region (match-beginning 1)
                                          (match-end 1) "\u2190")
                          nil)))))
#+END_SRC
*** Refactoring
#+BEGIN_SRC emacs-lisp
  (require-package 'js2-refactor)
  (require 'js2-refactor)

  (defadvice js2r-inline-var (after reindent-buffer activate)
    (cleanup-buffer))

  (js2r-add-keybindings-with-prefix "C-c C-m")
  (define-key js2-mode-map (kbd "M-SPC") 'js2r--ensure-just-one-space)
#+END_SRC
*** Code completion and analysis using Tern
#+BEGIN_SRC emacs-lisp
  (require-package 'tern)
  (require-package 'tern-auto-complete)
  (require 'tern)

  (add-hook 'js2-mode-hook (lambda () (tern-mode t)))

  (eval-after-load 'tern
    '(progn
       (require 'tern-auto-complete)
       (tern-ac-setup)))
#+END_SRC

*** Use HTML mode to edit tags processed by JSX
#+BEGIN_SRC emacs-lisp
  (require-package 'multi-web-mode)
  (setq mweb-default-major-mode 'js2-mode)
  (setq mweb-filename-extensions '("js" "jsx"))
  (setq mweb-tags '((html-mode "([[:space:]\n]*<"
                               ">[[:space:]\n]*)")))
  (multi-web-global-mode 1)
  (diminish 'multi-web-mode)
  (setq sgml-basic-offset 2)
#+END_SRC

*** DWIM new line indentation

#+BEGIN_SRC emacs-lisp
  (defun osener/newline-and-indent ()
    "Open a new brace or bracket expression, with relevant newlines and indent. "
    (interactive)
    (if (or (and (looking-back "(") (looking-at ")"))
            (and (looking-back "{") (looking-at "}")))
        (progn
          (newline-and-indent)
          (newline-and-indent)
          (forward-line -1)
          (indent-according-to-mode))
      (newline-and-indent)))

  (define-key js2-mode-map (kbd "RET") 'osener/newline-and-indent)
#+END_SRC

** Scala
#+BEGIN_SRC emacs-lisp
  (require-package 'scala-mode2)

  (let ((default-directory "~/vcs/ensime"))
    (when (file-exists-p default-directory)
      (add-to-list 'load-path (expand-file-name "elisp/"))
      (require 'ensime)))
#+END_SRC
* Webdev
** Stylus
#+BEGIN_SRC emacs-lisp
  (require-package 'stylus-mode)
  (after-load 'auto-complete
    (add-hook 'stylus-mode-hook
              (lambda ()
                (ac-css-mode-setup)
                (rainbow-mode t))))
#+END_SRC
* Eshell
Great intro post for eshell, also the source of some of these settings:
http://www.masteringemacs.org/articles/2010/12/13/complete-guide-mastering-eshell/

** Change some defaults
#+BEGIN_SRC emacs-lisp
  (eval-after-load 'esh-opt
    '(progn
       (require 'em-prompt)
       (setq eshell-cmpl-ignore-case t)
       (setq eshell-prefer-lisp-functions t)
       (setq eshell-where-to-jump 'begin)
       (setq eshell-review-quick-commands nil)
       (setq eshell-smart-space-goes-to-end t)
       (setq eshell-directory-name
             (expand-file-name "./" (expand-file-name "eshell" user-emacs-directory)))))
#+END_SRC

** Convenience function for usage in a terminal emulator
This allows you to use eshell in a similar fashion to standard Unix
shells in a terminal emulator.

Call Emacs like this for an one-off eshell buffer:
emacsclient -a '' -t -e "(server-eshell)"
#+BEGIN_SRC emacs-lisp
  (defun server-eshell ()
    "Command to be called by emacs-client to start a new shell.

  A new eshell will be created. When the frame is closed, the buffer is
  deleted or the shell exits, then hooks will take care that the other
  actions happen. For example, when the frame is closed, then the buffer
  will be deleted and the client disconnected.

  Also creates a local binding of 'C-x #' to kill the buffer."
    (lexical-let ((buf (eshell t))
                  (client (first server-clients))
                  (frame (selected-frame)))
      (labels ((close (&optional arg)
                      (when (not (boundp 'cve/recurse))
                        (let ((cve/recurse t))
                          (delete-frame frame)
                          (kill-buffer buf)
                          (server-delete-client client)))))
        (add-hook 'eshell-exit-hook #'close t t)
        (add-hook 'delete-frame-functions #'close t t))
      (local-set-key (kbd "C-x #") (lambda () (interactive) (kill-buffer buf)))
      (delete-other-windows)
      nil))
#+END_SRC

** Quake-like eshell window
#+BEGIN_SRC emacs-lisp
  (require-package 'shell-pop)

  (setq shell-pop-window-position "bottom"
        shell-pop-window-height 50
        shell-pop-shell-type '("eshell" "*eshell*" (lambda () (eshell))))

  (global-set-key (kbd "<f8>") 'shell-pop)

#+END_SRC

** Easy way to open eshell in the directory of current buffer
[[https://github.com/technomancy/emacs-starter-kit/commit/c0e568d3c9940c9dd5241e4b49467723590fc2c2][From here]]
#+BEGIN_SRC emacs-lisp
(defun eshell-in-dir (&optional prompt)
  "Change the directory of an existing eshell to the directory of the file in
the current buffer or launch a new eshell if one isn't running. If the
current buffer does not have a file (e.g., a *scratch* buffer) launch or raise
eshell, as appropriate. Given a prefix arg, prompt for the destination
directory."
  (interactive "P")
  (let* ((original-buffer (current-buffer))
         (name (buffer-file-name))
         (dir (cond (prompt (read-directory-name "Directory: " nil nil t))
                    (name (file-name-directory name))
                    (t nil)))
         (buffers (delq nil (mapcar (lambda (buf)
                                      (with-current-buffer buf
                                        (when (eq 'eshell-mode major-mode)
                                          (buffer-name))))
                                    (buffer-list))))
         (buffer (cond ((eq 1 (length buffers)) (first buffers))
                       ((< 1 (length buffers)) (ido-completing-read
                                                "Eshell buffer: " buffers nil t
                                                nil nil (first buffers)))
                       (t (eshell)))))
    (with-current-buffer buffer
      (when dir
        (eshell/cd (list dir))
        (eshell-send-input))
      (end-of-buffer)
      (switch-to-buffer original-buffer)
      (shell-pop-up))))
#+END_SRC

** Clickable ls output
[[http://www.emacswiki.org/emacs/EshellEnhancedLS][From EmacsWiki]]
#+BEGIN_SRC emacs-lisp
  (eval-after-load "em-ls"
    '(progn
       (defun ted-eshell-ls-find-file-at-point (point)
         "RET on Eshell's `ls' output to open files."
         (interactive "d")
         (find-file
          (replace-regexp-in-string
           "[ \t\n]*$" ""
           (replace-regexp-in-string
            "^[ \t\n]*" ""
            (buffer-substring-no-properties
             (previous-single-property-change point 'help-echo)
             (next-single-property-change point 'help-echo))))))

       (defun pat-eshell-ls-find-file-at-mouse-click (event)
         "Middle click on Eshell's `ls' output to open files.
   From Patrick Anderson via the wiki."
         (interactive "e")
         (ted-eshell-ls-find-file-at-point (posn-point (event-end event))))

       (let ((map (make-sparse-keymap)))
         (define-key map (kbd "RET")      'ted-eshell-ls-find-file-at-point)
         (define-key map (kbd "<return>") 'ted-eshell-ls-find-file-at-point)
         (define-key map (kbd "<mouse-2>") 'pat-eshell-ls-find-file-at-mouse-click)
         (defvar ted-eshell-ls-keymap map))

       (defadvice eshell-ls-decorated-name (after ted-electrify-ls activate)
         "Eshell's `ls' now lets you click or RET on file names to open them."
         (add-text-properties 0 (length ad-return-value)
                              (list 'help-echo "RET, mouse-2: visit this file"
                                    'mouse-face 'highlight
                                    'keymap ted-eshell-ls-keymap)
                              ad-return-value)
         ad-return-value)))
#+END_SRC

** Colorize prompt on nonzero exit codes
#+BEGIN_SRC emacs-lisp
  (defface esk-eshell-error-prompt-face
    '((((class color) (background dark)) (:foreground "red" :bold t))
      (((class color) (background light)) (:foreground "red" :bold t)))
    "Face for nonzero prompt results"
    :group 'eshell-prompt)

  (add-hook 'eshell-after-prompt-hook
            (defun esk-eshell-exit-code-prompt-face ()
              (when (and eshell-last-command-status
                         (not (zerop eshell-last-command-status)))
                (let ((inhibit-read-only t))
                  (add-text-properties
                   (save-excursion (beginning-of-line) (point)) (point-max)
                   '(face esk-eshell-error-prompt-face))))))
#+END_SRC

** Misc commands
#+BEGIN_SRC emacs-lisp
  (defun eshell/cds ()
    "Change directory to the project's root."
    (eshell/cd (locate-dominating-file default-directory "src")))

  (defun eshell/cdl ()
    "Change directory to the project's root."
    (eshell/cd (locate-dominating-file default-directory "lib")))

  (defun eshell/cdg ()
    "Change directory to the project's root."
    (eshell/cd (locate-dominating-file default-directory ".git")))
#+END_SRC

* Term
Don't keep buffers with finished processes around
#+BEGIN_SRC emacs-lisp
  (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
    (if (memq (process-status proc) '(signal exit))
        (let ((buffer (process-buffer proc)))
          ad-do-it
          (kill-buffer buffer))
      ad-do-it))
  (ad-activate 'term-sentinel)
#+END_SRC

Yank into terminal with C-y
#+BEGIN_SRC emacs-lisp
  (add-hook 'term-mode-hook
            (lambda () (define-key term-raw-map (kbd "C-y") 'term-paste)))
#+END_SRC

Increase max buffer size
#+BEGIN_SRC emacs-lisp
  (add-hook 'term-mode-hook
            (lambda ()
              (setq term-buffer-maximum-size 10000)))
#+END_SRC

Multi-term
#+BEGIN_SRC emacs-lisp
  (require-package 'multi-term)

  (setq multi-term-program "/usr/local/bin/fish")

  (add-hook 'term-mode-hook
            (lambda ()
              (setq term-bind-key-alist
                    (append term-bind-key-alist
                            '(("M-[" . multi-term-prev)
                              ("M-]" . multi-term-next)
                              ("M-d" . term-send-forward-kill-word)
                              ("M-DEL" . term-send-forward-kill-word)
                              ("C-DEL" . term-send-forward-kill-word)
                              ("M-<backspace>" . term-send-backward-kill-word)
                              ("C-<backspace>" . term-send-backward-kill-word)
                              ("M-<right>" . term-send-forward-word)
                              ("C-<right>" . term-send-forward-word)
                              ("M-<left>" . term-send-backward-word)
                              ("C-<left>" . term-send-backward-word))))))
#+END_SRC

* Dired
Toggleable verbosity
#+BEGIN_SRC emacs-lisp
  (require-package 'dired-details)
  (require-package 'dired-details+)

  (require 'dired-details+)
  (setq-default dired-details-hidden-string "--- ")
#+END_SRC

Custom ls invocation
#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches
        "-aGhlvF --group-directories-first --time-style=long-iso")
#+END_SRC

Try guessing dired targets
#+BEGIN_SRC emacs-lisp
  (setq dired-dwim-target t)
#+END_SRC

Don't ask before doing recursive copies
#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-copies 'always)
#+END_SRC

Display changed files
#+BEGIN_SRC emacs-lisp
  (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
#+END_SRC

* Navigation
Goto line with feedback
#+BEGIN_SRC emacs-lisp
  (global-set-key [remap goto-line] 'goto-line-with-feedback)

  (defun goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input"
    (interactive)
    (if (and (boundp 'linum-mode)
             linum-mode)
        (call-interactively 'goto-line)
      (unwind-protect
          (progn
            (linum-mode 1)
            (call-interactively 'goto-line))
        (linum-mode -1))))
#+END_SRC

Project explorer
#+BEGIN_SRC emacs-lisp
  (require-package 'project-explorer)
  (autoload 'project-explorer-open "project-explorer"
    "Show or create the project explorer for the current project." t)
  (autoload 'project-explorer-helm "project-explorer"
    "Browse the project using helm." t)
  (setq pe/omit-regex "^\\.\\|^#\\|~$\\|^node_modules$")

  (global-set-key (kbd "s-t") 'project-explorer-helm)
#+END_SRC

* Window management
Popwin
#+BEGIN_SRC emacs-lisp
  (require-package 'popwin)

  (require 'popwin)
  (setq display-buffer-function 'popwin:display-buffer)

  (setq popwin:special-display-config
        '(("*Help*" :height 30 :stick t)
          ("*Completions*" :noselect t)
          ("*compilation*" :noselect t)
          ("*Messages*" :height 30)
          ("*Directory*" :noselect t)
          ("*Packages*" :height 30)
          ("\\*Slime Description.*" :noselect t :regexp t :height 30)
          ("*magit-commit*" :noselect t :height 40 :width 80)
          ("*magit-diff*" :noselect t :height 40 :width 80)
          ("*magit-edit-log*" :noselect t :height 15 :width 80)
          ("\\*Slime Inspector.*" :regexp t :height 30)
          ("*Ido Completions*" :noselect t :height 30)
          ("\\*ansi-term\\*.*" :regexp t :height 30)
          ("*shell*" :height 30)
          ("*gists*" :height 30)
          ("*sldb.*":regexp t :height 30)
          ("*nrepl-error*" :noselect t)))
#+END_SRC
Rotate windows
#+BEGIN_SRC emacs-lisp
  (defun rotate-windows ()
    "Rotate your windows"
    (interactive)
    (cond ((not (> (count-windows)1))
           (message "You can't rotate a single window!"))
          (t
           (setq i 1)
           (setq numWindows (count-windows))
           (while  (< i numWindows)
             (let* (
                    (w1 (elt (window-list) i))
                    (w2 (elt (window-list) (+ (% i numWindows) 1)))

                    (b1 (window-buffer w1))
                    (b2 (window-buffer w2))

                    (s1 (window-start w1))
                    (s2 (window-start w2))
                    )
               (set-window-buffer w1  b2)
               (set-window-buffer w2 b1)
               (set-window-start w1 s2)
               (set-window-start w2 s1)
               (setq i (1+ i)))))))
#+END_SRC

Toggle window split
#+BEGIN_SRC emacs-lisp
  (defun toggle-window-split ()
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))
#+END_SRC

Easy window navigation using M-1..M-0
#+BEGIN_SRC emacs-lisp
  (require-package 'window-numbering)
  (window-numbering-mode t)
#+END_SRC

Keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x -") 'rotate-windows)
  (global-set-key (kbd "C-x C--") 'toggle-window-split)
  (global-unset-key (kbd "C-x C-+")) ;; don't zoom like this
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun toggle-fullscreen ()
    "Toggle full screen"
    (interactive)
    (set-frame-parameter
     nil 'fullscreen
     (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

  (global-set-key (kbd "<f11>") 'toggle-fullscreen)
#+END_SRC

* Chat
** ERC
Unique nick colorization
#+BEGIN_SRC emacs-lisp
  (require-package 'erc-hl-nicks)
#+END_SRC

Disable trailing whitespace in ERC buffers
#+BEGIN_SRC emacs-lisp
  (add-hook 'erc-mode-hook (lambda ()
                                (setq show-trailing-whitespace nil)))
#+END_SRC

* Helm
#+BEGIN_SRC emacs-lisp
  (require-package 'helm)
  (require-package 'helm-swoop)

  (require 'helm-config)

  (helm-mode -1)
#+END_SRC

Keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f1>") 'helm-mini)
  (global-set-key (kbd "M-i") 'helm-swoop)
  (global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
  (define-key org-mode-map (kbd "C-x TAB") 'helm-org-headlines)
#+END_SRC

* Git
Toggle whitespace in magit-status buffers
#+BEGIN_SRC emacs-lisp
  (require 'magit)

  (defun magit-toggle-whitespace ()
    (interactive)
    (if (member "-w" magit-diff-options)
        (magit-dont-ignore-whitespace)
      (magit-ignore-whitespace)))

  (defun magit-ignore-whitespace ()
    (interactive)
    (add-to-list 'magit-diff-options "-w")
    (magit-refresh))

  (defun magit-dont-ignore-whitespace ()
    (interactive)
    (setq magit-diff-options (remove "-w" magit-diff-options))
    (magit-refresh))

  (define-key magit-status-mode-map (kbd "W") 'magit-toggle-whitespace)
#+END_SRC

Add keybinding for toggling --no-merges in log view
#+BEGIN_SRC emacs-lisp
  (eval-after-load 'magit-key-mode
    '(magit-key-mode-insert-switch 'logging "-l" "No merges" "--no-merges"))
#+END_SRC

Diff-hl mode
#+BEGIN_SRC emacs-lisp
  (require-package 'diff-hl)
  (global-diff-hl-mode t)
#+END_SRC

Style-checking for git commit messages
#+BEGIN_SRC emacs-lisp
  (require-package 'git-commit-mode)
#+END_SRC

Misc
#+BEGIN_SRC emacs-lisp
  (setq magit-diff-refine-hunk 'all)
#+END_SRC

* OSX related tweaks
Input related tweaks
#+BEGIN_SRC emacs-lisp
  (when *is-a-mac*
    (setq mac-command-modifier 'super)
    (setq mac-option-modifier 'meta)
    (setq mouse-wheel-scroll-amount '(0.001)))
#+END_SRC

* Cosmetic changes
Set default font
#+BEGIN_SRC emacs-lisp
  (if *is-a-mac*
      (add-to-list 'default-frame-alist
                   '(font . "Akkurat-Mono-13"))
    (add-to-list 'default-frame-alist
                 '(font . "Akkurat-Mono-11")))
#+END_SRC

Set Unicode font
#+BEGIN_SRC emacs-lisp
  (set-fontset-font "fontset-default" 'unicode (if *is-a-mac* "Menlo" "Symbola"))
#+END_SRC

Disable bold faces
#+BEGIN_SRC emacs-lisp
  (mapc
   (lambda (face)
     (set-face-attribute face nil :weight 'normal :underline nil))
   (face-list))
#+END_SRC

Use proportional fonts in mode-line
#+BEGIN_SRC emacs-lisp
  (run-at-time "1 sec" nil
               (lambda ()
                 (set-face-attribute 'mode-line nil
                                     :family (if *is-a-mac* "Muli" "Muli-Regular"))))
#+END_SRC

Use UTF-8 bullets on org-mode buffers
#+BEGIN_SRC emacs-lisp
  (require-package 'org-bullets)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+END_SRC

Fontify code blocks in org-mode buffers
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

Turn on `org-indent-mode' on startup
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
#+END_SRC

Parse ansi color escape codes in compilation-mode buffers
#+BEGIN_SRC emacs-lisp
  (require 'ansi-color)
  (defun colorize-compilation-buffer ()
    (toggle-read-only)
    (ansi-color-apply-on-region (point-min) (point-max))
    (toggle-read-only))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+END_SRC

Use different background colors for even and odd lines in some modes.
#+BEGIN_SRC emacs-lisp
  (require-package 'stripe-buffer)

  (add-hook 'dired-mode-hook 'stripe-listify-buffer)
  (add-hook 'emms-playlist-mode-hook 'stripe-listify-buffer)
  (add-hook 'org-mode-hook 'turn-on-stripe-table-mode)
#+END_SRC

* Misc Emacs modes
M-x find-file http://en.wikipedia.org/wiki/Main_Page
#+BEGIN_SRC emacs-lisp
  (url-handler-mode t)
#+END_SRC

** Smartparens
#+BEGIN_SRC emacs-lisp
  (require-package 'smartparens)
  (setq sp-base-key-bindings 'paredit)
  (smartparens-global-strict-mode t)
  (diminish 'smartparens-mode)
  (require 'smartparens-config)
#+END_SRC

** Convenient bookmarking using bm
#+BEGIN_SRC emacs-lisp
  (require-package 'bm)

  (global-set-key (kbd "<M-f2>") 'bm-toggle)
  (global-set-key (kbd "<f2>")   'bm-next)
  (global-set-key (kbd "<S-f2>") 'bm-previous)
  (global-set-key (kbd "<left-fringe> <mouse-1>") 'bm-toggle-mouse)
  (global-set-key (kbd "<left-fringe> <wheel-down>") 'bm-next-mouse)
  (global-set-key (kbd "<left-fringe> <wheel-up>") 'bm-previous-mouse)
#+END_SRC

** Browsers
#+BEGIN_SRC emacs-lisp
  (require-package 'w3m)
  (setq w3m-command "/usr/local/bin/w3m")
  (setq browse-url-browser-function 'browse-url-default-browser)
#+END_SRC

** Disable hl-line-mode
#+BEGIN_SRC emacs-lisp
  (remove-hook 'prog-mode-hook 'esk-turn-on-hl-line-mode)
#+END_SRC

** ag
Editable buffer
#+BEGIN_SRC emacs-lisp
  (require-package 'wgrep-ack)
  (add-hook 'ag-mode-hook 'wgrep-ack-and-a-half-setup)
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-enable-key "w")
  (setq wgrep-change-readonly-file t)
#+END_SRC

** Shell
Use fish shell
#+BEGIN_SRC emacs-lisp
  (setq explicit-shell-file-name "/usr/local/bin/fish")
#+END_SRC

Get the PATH from fish
#+BEGIN_SRC emacs-lisp
  (if (and (not (getenv "TERM_PROGRAM"))
           (executable-find "/usr/local/bin/fish"))
      (let ((path (split-string
                   (shell-command-to-string
                    "/usr/local/bin/fish -c \"printf \\\"\\\$PATH\\\"\"")
                   " ")))
        (setq exec-path path)
        (setenv "PATH" (mapconcat 'identity path ":"))))
#+END_SRC

** Snippets
#+BEGIN_SRC emacs-lisp
  (yas-global-mode 1)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (diminish 'yas-minor-mode)
#+END_SRC

*** Helper functions
JavaScript [[https://github.com/magnars/.emacs.d/blob/master/defuns/snippet-helpers.el][(From here)]]
#+BEGIN_SRC emacs-lisp
  (defun js-method-p ()
    (save-excursion
      (word-search-backward "function")
      (looking-back ": ")))

  (defun js-function-declaration-p ()
    (save-excursion
      (word-search-backward "function")
      (looking-back "^\\s *")))

  (defun snippet--function-punctuation ()
    (if (js-method-p)
        (when (not (looking-at "[ \n\t\r]*}"))
          (insert ","))
      (unless (js-function-declaration-p)
        (if (looking-at "$") (insert ";")))))

  (defun snippet--function-name ()
    (if (js-function-declaration-p) "name" ""))
#+END_SRC

** Slate configuration language
#+BEGIN_SRC emacs-lisp
  (require 'slate-config-mode)
#+END_SRC

** EMMS
#+BEGIN_SRC emacs-lisp
  (require-package 'emms)

  (autoload 'emms-browser "emms-browser"
    "Launch or switch to the EMMS Browser." t)
  (autoload 'emms "emms-playlist-mode"
    "Switch to the current emms-playlist buffer." t)

  (eval-after-load "emms"
    `(progn
       (emms-devel)
       (emms-default-players)

       (if (require 'emms-info-libtag nil t)
           (add-to-list 'emms-info-functions 'emms-info-libtag
                        nil 'eq))
       (require 'emms-mark nil t)

       (require 'emms-history)
       (emms-history-load)

       ;; swap time and other track info
       (let ((new-global-mode-string nil))
         (while (and (not (memq (car global-mode-string)
                                '(emms-mode-line-string
                                  emms-playing-time-string)))
                     global-mode-string)
           (push (car global-mode-string) new-global-mode-string)
           (setq global-mode-string (cdr global-mode-string)))
         (setq global-mode-string
               (nconc (nreverse new-global-mode-string)
                      '(emms-playing-time-string
                        emms-mode-line-string))))
       (add-hook 'emms-player-started-hook 'emms-show)


       (defun my-emms-covers (dir type)
         "Choose album cover in DIR deppending on TYPE.
          Small cover should be less than 80000 bytes.
          Medium - less than 120000 bytes."
         (let* ((pics (directory-files-and-attributes
                       dir t "\\.\\(jpe?g\\|png\\|gif\\|bmp\\)$" t))
                (pic (car pics))
                (pic-size (nth 8 pic)))
           (let (temp)
             (cond
              ((eq type 'small)
               (while (setq temp (cadr pics))
                 (let ((temp-size (nth 8 temp)))
                   (if (< temp-size pic-size)
                       (setq pic temp
                             pic-size temp-size)))
                 (setq pics (cdr pics)))
               (if (<= (or pic-size 80001) 80000)
                   (car pic)))
              ((eq type 'medium)
               (if (and pic (setq temp (cadr pics)))
                   (progn
                     (setq pics (cdr pics))
                     (let ((temp-size (nth 8 temp)))
                       (let ((small temp)
                             (small-size temp-size))
                         (if (< pic-size small-size)
                             (setq small pic
                                   small-size pic-size
                                   pic temp
                                   pic-size temp-size))
                         (while (setq temp (cadr pics))
                           (setq temp-size (nth 8 temp))
                           (cond
                            ((< temp-size small-size)
                             (setq pic small
                                   pic-size small-size
                                   small temp
                                   small-size temp-size))
                            ((< temp-size pic-size)
                             (setq pic temp
                                   pic-size temp-size)))
                           (setq pics (cdr pics)))
                         (car (if (<= pic-size 120000) pic
                                small)))))
                 (car pic)))
              ((eq type 'large)
               (while (setq temp (cadr pics))
                 (let ((temp-size (nth 8 temp)))
                   (if (> temp-size pic-size)
                       (setq pic temp
                             pic-size temp-size)))
                 (setq pics (cdr pics)))
               (car pic))))))

       (setq emms-show-format "ðŸŽµ %s"
             emms-mode-line-format "%s"
             emms-playing-time-display-format "ðŸŽµ %s "
             emms-source-file-default-directory "~/Music"
             emms-browser-covers 'my-emms-covers)

       (require 'emms-player-mplayer)
       (define-emms-simple-player mplayer '(file url)
         (regexp-opt '(".ogg" ".mp3" ".wav" ".mpg" ".mpeg" ".wmv" ".wma"
                       ".mov" ".avi" ".divx" ".ogm" ".asf" ".mkv" "http://" "mms://"
                       ".rm" ".rmvb" ".mp4" ".flac" ".vob" ".m4a" ".flv" ".ogv" ".pls"))
         "mplayer" "-slave" "-quiet" "-really-quiet" "-fullscreen")

       (require 'emms-info-metaflac)
       (add-to-list 'emms-info-functions 'emms-info-metaflac nil 'eq)

       (global-set-key (kbd "C-c p") 'emms-pause)
       (global-set-key (kbd "C-c s") 'emms-stop)


       ;; track info ticker
       (defun string-shift-left (str &optional offset)
         "Shift STR content to the left OFFSET characters."
         (or offset (setq offset 1))
         (let ((str-len (length str)))
           (if (< offset str-len)
               (concat (substring-no-properties str offset)
                       (substring-no-properties str 0 offset))
             str)))

       (defun emms-tick-mode-line-description (offset)
         "Tick emms track description OFFSET characters."
         (setq emms-mode-line-string
               (string-shift-left emms-mode-line-string offset)))

       (defvar *my-emms-ticker* nil
         "Timer for current track info ticker.")

       (defun emms-track-ticker-start ()
         "Start ticking current TRACK info."
         (or *my-emms-ticker*
             (setq *my-emms-ticker*
                   (run-at-time t 2
                                'emms-tick-mode-line-description 5))))

       (defun emms-track-ticker-stop ()
         "Stop ticking current TRACK info."
         (when *my-emms-ticker*
           (cancel-timer *my-emms-ticker*)
           (setq *my-emms-ticker* nil)))


       (add-hook 'emms-player-started-hook 'emms-track-ticker-start)
       (add-hook 'emms-player-stopped-hook 'emms-track-ticker-stop)
       (add-hook 'emms-player-finished-hook 'emms-track-ticker-stop)
       (add-hook 'emms-player-paused-hook
                 (lambda () "Start/Stop track ticker."
                   (if *my-emms-ticker*
                       (emms-track-ticker-stop)
                     (emms-track-ticker-start))))))
#+END_SRC
** Browse documentation using Dash
#+BEGIN_SRC emacs-lisp
  (defun define-dash-docset (mode-hook prefix)
    (add-hook mode-hook `(lambda () (setq dash-at-point-docset ,prefix))))

  (when *is-a-mac*
    (require-package 'dash-at-point)
    (make-variable-buffer-local 'dash-at-point-docset)
    (define-dash-docset 'c-mode-hook "c")
    (define-dash-docset 'c++-mode-hook "cpp")
    (define-dash-docset 'clojure-mode-hook "clojure")
    (define-dash-docset 'js2-mode-hook "js")
    (define-dash-docset 'emacs-lisp-mode-hook "elisp")
    (define-dash-docset 'yaml-mode-hook "ansible")
    (global-set-key "\C-cd" 'dash-at-point))
#+END_SRC

** Jenkins integration
#+BEGIN_SRC emacs-lisp
  (require-package 'butler)
  (require 'butler)
#+END_SRC

** Guide-key
#+BEGIN_SRC emacs-lisp
  (require-package 'guide-key)
  (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-x v" "C-x 8"))
  (guide-key-mode t)
  (diminish 'guide-key-mode)
  (setq guide-key/recursive-key-sequence-flag t)
  (setq guide-key/popup-window-position 'bottom)
  (setq guide-key/idle-delay 0.0)

#+END_SRC
** Which-function
#+BEGIN_SRC emacs-lisp
  (which-function-mode 1)
#+END_SRC

** Deft
#+BEGIN_SRC emacs-lisp
  (require-package 'deft)

  (setq deft-directory "~/Dropbox/Documents"
        deft-extension "org"
        deft-text-mode 'org-mode
        deft-use-filename-as-title t)

  (global-set-key (kbd "<f9>") 'deft)
#+END_SRC

* Misc keybindings
Quick way to open a link
#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-cb" 'org-open-at-point-global)
#+END_SRC

Switch to previous buffer
#+BEGIN_SRC emacs-lisp
  (global-set-key "\M-O" 'mode-line-other-buffer)
#+END_SRC

* Misc tweaks
Use system Trash
#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)
#+END_SRC

No bell whatsoever please
#+BEGIN_SRC emacs-lisp
  (setq visual-bell nil)
  (setq ring-bell-function 'ignore)
#+END_SRC

Disable show-trailing-whitespace in some modes
#+BEGIN_SRC emacs-lisp
  (dolist (hook '(erc-mode-hook
                  term-mode-hook
                  eshell-mode-hook
                  nrepl-mode-hook
                  inferior-python-mode-hook
                  inferior-emacs-lisp-mode
                  helm-update-hook
                  slime-repl-mode-hook
                  mu4e-main-mode-hook
                  mu4e-headers-mode-hook
                  mu4e-view-mode-hook
                  jabber-roster-mode-hook
                  jabber-chat-mode-hook
                  jabber-browse-mode-hook))
    (add-hook hook (lambda () (setq show-trailing-whitespace nil))))
#+END_SRC

Disable yasnippet in some modes
#+BEGIN_SRC emacs-lisp
  (add-hook 'term-mode-hook (lambda()
                  (yas-minor-mode -1)))
#+END_SRC

Wrap lines longer than 79 characters
#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 79)
#+END_SRC

Set tmp dir to ~/.emacs.d/tmp
#+BEGIN_SRC emacs-lisp
  (setq temporary-file-directory (expand-file-name "tmp/" user-emacs-directory))

  (make-directory temporary-file-directory t)

  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t)))
#+END_SRC

Cleanup buffers before saving
#+BEGIN_SRC emacs-lisp
  (defun untabify-buffer ()
    (interactive)
    (untabify (point-min) (point-max)))

  (defun indent-buffer ()
    (interactive)
    (indent-region (point-min) (point-max)))

  (defun cleanup-buffer-safe ()
    "Perform a bunch of safe operations on the whitespace content of a buffer.
  Does not indent buffer, because it is used for a before-save-hook, and that
  might be bad."
    (interactive)
    (delete-trailing-whitespace)
    (set-buffer-file-coding-system 'utf-8))

  (defun cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer.
  Including indent-buffer, which should not be called automatically on save."
    (interactive)
    (cleanup-buffer-safe)
    (untabify-buffer)
    (indent-buffer))

  (add-hook 'before-save-hook 'cleanup-buffer-safe)

  (global-set-key (kbd "C-c n") 'cleanup-buffer)
  (global-set-key (kbd "C-c C-<return>") 'delete-blank-lines)
#+END_SRC
